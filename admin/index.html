<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Viewo 관리자</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    /* ===== 테마 팔레트 ===== */
    :root {
      /* 기본 색상 팔레트 */
      --color-primary-50: #e8f1ff;
      --color-primary-100: #d4e5ff;
      --color-primary-200: #aecbff;
      --color-primary-300: #7aabff;
      --color-primary-400: #4d8bf7;
      --color-primary-500: #256ef4;
      --color-primary-600: #1a5cd4;
      --color-primary-700: #1449a8;
      --color-primary-800: #0f3680;
      --color-primary-900: #0a2358;

      --color-danger-50: #fef2f2;
      --color-danger-100: #fee2e2;
      --color-danger-200: #fecaca;
      --color-danger-300: #fca5a5;
      --color-danger-400: #f87171;
      --color-danger-500: #ef4444;
      --color-danger-600: #dc2626;
      --color-danger-700: #b91c1c;
      --color-danger-800: #991b1b;
      --color-danger-900: #7f1d1d;

      --color-success-50: #f0fdf4;
      --color-success-100: #dcfce7;
      --color-success-200: #bbf7d0;
      --color-success-300: #86efac;
      --color-success-400: #4ade80;
      --color-success-500: #22c55e;
      --color-success-600: #16a34a;
      --color-success-700: #15803d;
      --color-success-800: #166534;
      --color-success-900: #14532d;

      --color-warning-50: #fffbeb;
      --color-warning-100: #fef3c7;
      --color-warning-200: #fde68a;
      --color-warning-300: #fcd34d;
      --color-warning-400: #fbbf24;
      --color-warning-500: #f59e0b;
      --color-warning-600: #d97706;
      --color-warning-700: #b45309;
      --color-warning-800: #92400e;
      --color-warning-900: #78350f;

      --color-gray-50: #f9fafb;
      --color-gray-100: #f3f4f6;
      --color-gray-200: #e5e7eb;
      --color-gray-300: #d1d5db;
      --color-gray-400: #9ca3af;
      --color-gray-500: #6b7280;
      --color-gray-600: #4b5563;
      --color-gray-700: #374151;
      --color-gray-800: #1f2937;
      --color-gray-900: #111827;
      --color-gray-950: #030712;

      --color-white: #ffffff;
      --color-black: #000000;

      /* 특수 색상 */
      --color-current-location: #FFEB3B;
      --color-current-location-dark: #FDD835;
      --color-logo: #151419;
      --color-text-default: #333333;

      /* 시맨틱 색상 변수 (테마 변경 시 이 부분만 수정) */
      --primary: var(--color-primary-500);
      --primary-dark: var(--color-primary-600);
      --primary-light: var(--color-primary-50);
      --danger: var(--color-danger-500);
      --danger-dark: var(--color-danger-600);
      --danger-light: var(--color-danger-50);
      --success: var(--color-success-500);
      --success-light: var(--color-success-50);
      --warning: var(--color-warning-500);
      --warning-light: var(--color-warning-50);
      --gray-50: var(--color-gray-50);
      --gray-100: var(--color-gray-100);
      --gray-200: var(--color-gray-200);
      --gray-300: var(--color-gray-300);
      --gray-400: var(--color-gray-400);
      --gray-500: var(--color-gray-500);
      --gray-600: var(--color-gray-600);
      --gray-700: var(--color-gray-700);
      --gray-800: var(--color-gray-800);
      --gray-900: var(--color-gray-900);
      --white: var(--color-white);
      --black: var(--color-black);

      /* 투명도 포함 색상 */
      --overlay-bg: rgba(0, 0, 0, 0.5);
      --primary-alpha-10: rgba(37, 110, 244, 0.1);
      --primary-alpha-15: rgba(37, 110, 244, 0.15);
      --primary-alpha-20: rgba(37, 110, 244, 0.2);
      --danger-alpha-20: rgba(239, 68, 68, 0.2);
      --white-alpha-05: rgba(255, 255, 255, 0.05);
      --white-alpha-10: rgba(255, 255, 255, 0.1);
      --white-alpha-90: rgba(255, 255, 255, 0.9);
      --current-location-alpha-20: rgba(255, 235, 59, 0.2);
      --current-location-alpha-30: rgba(255, 235, 59, 0.3);

      /* 텍스트 색상 */
      --text-primary: var(--color-gray-900);
      --text-secondary: var(--color-gray-500);
      --text-tertiary: var(--color-gray-400);
      --text-inverse: var(--color-white);
      --text-default: var(--color-text-default);
      --text-dark: var(--color-black);

      /* 배경 색상 */
      --bg-primary: var(--color-white);
      --bg-secondary: var(--color-gray-100);
      --bg-tertiary: var(--color-gray-50);
      --bg-inverse: var(--color-gray-900);

      /* 테두리 색상 */
      --border-light: var(--color-gray-200);
      --border-default: var(--color-gray-300);
      --border-dark: var(--color-gray-400);

      /* 현위치 색상 */
      --current-location: var(--color-current-location);
      --current-location-dark: var(--color-current-location-dark);

      /* 로고 색상 */
      --logo-color: var(--color-logo);
      --logo-color-inverse: var(--color-white);

      /* 사이드바 색상 */
      --sidebar-bg: linear-gradient(180deg, var(--gray-800) 0%, var(--gray-900) 100%);
      --sidebar-text: var(--gray-400);
      --sidebar-active-text: var(--primary);
      --sidebar-active-bg: rgba(37, 110, 244, 0.15);

      /* 메인 배경 및 카드 */
      --bg-main: var(--gray-100);
      --bg-card: var(--white);

      /* 그림자 */
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

      /* 반경 */
      --radius: 12px;
      --radius-sm: 8px;
      --radius-lg: 16px;

      /* 그라데이션 */
      --gradient-primary: linear-gradient(135deg, var(--primary-light) 0%, var(--color-primary-100) 100%);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-main);
      color: var(--text-primary);
      min-height: 100vh;
      transition: background 0.3s ease;
    }

    /* ===== 로그인 페이지 ===== */
    .login-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: var(--bg-main);
      transition: background 0.3s ease;
    }

    .login-card {
      width: 100%;
      max-width: 420px;
      background: var(--bg-card);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      padding: 48px 40px;
      border: 1px solid var(--border-default);
      transition: background 0.3s ease, border-color 0.3s ease;
    }

    .login-logo {
      text-align: center;
      margin-bottom: 32px;
    }

    .login-logo svg {
      width: 140px;
      height: auto;
      color: var(--logo-color);
    }

    .login-logo svg path {
      fill: currentColor;
    }

    .login-title {
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      margin-bottom: 8px;
      color: var(--text-primary);
      transition: color 0.3s ease;
    }

    .login-subtitle {
      font-size: 14px;
      text-align: center;
      color: var(--text-secondary);
      margin-bottom: 32px;
      transition: color 0.3s ease;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      transition: color 0.3s ease;
    }

    .form-input {
      width: 100%;
      padding: 14px 16px;
      font-size: 15px;
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      background: var(--bg-card);
      color: var(--text-primary);
      transition: border-color 0.2s, box-shadow 0.2s, background 0.3s ease;
      font-family: inherit;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px var(--primary-light);
    }

    .form-input::placeholder {
      color: var(--text-secondary);
    }

    select.form-input {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 24px;
      font-size: 15px;
      font-weight: 600;
      border-radius: var(--radius-sm);
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }

    .btn-primary {
      /* width: 100%; */
      background: var(--primary);
      color: var(--white);
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-primary:disabled {
      background: var(--gray-300);
      cursor: not-allowed;
    }

    .btn-secondary {
      background: var(--gray-100);
      color: var(--gray-700);
      border: 1px solid var(--gray-300);
    }

    .btn-secondary:hover {
      background: var(--gray-200);
    }

    .btn-danger {
      background: var(--danger);
      color: var(--white);
    }

    .btn-danger:hover {
      background: var(--danger-dark);
    }

    .btn-sm {
      padding: 8px 16px;
      font-size: 13px;
    }

    .btn-lg {
      /* padding: 14px 28px; */
      font-size: 15px;
      min-height: 48px;
    }

    .btn-md {
      padding: 10px 20px;
      font-size: 14px;
      min-height: 36px;
    }

    .btn-outline {
      background: var(--white);
      color: var(--primary);
      border: 1.5px solid var(--primary);
      height: 100%;
    }

    .btn-outline:hover {
      background: var(--primary-light);
    }

    .login-error {
      background: var(--danger-light);
      color: var(--danger);
      padding: 12px 16px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      margin-bottom: 20px;
      display: none;
    }

    .login-error.show {
      display: block;
    }

    /* ===== 대시보드 레이아웃 ===== */
    .dashboard {
      display: none;
      min-height: 100vh;
    }

    .dashboard.show {
      display: block;
    }

    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 260px;
      height: 100vh;
      background: var(--sidebar-bg);
      padding: 24px 0;
      display: flex;
      flex-direction: column;
    }

    .sidebar-logo {
      padding: 0 24px;
      margin-bottom: 32px;
    }

    .sidebar-logo svg {
      width: 120px;
      height: auto;
      color: var(--logo-color-inverse);
    }

    .sidebar-logo svg path {
      fill: currentColor;
    }

    .sidebar-nav {
      flex: 1;
    }

    .nav-section {
      margin-bottom: 24px;
    }

    .nav-section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--gray-500);
      padding: 0 24px;
      margin-bottom: 8px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 24px;
      color: var(--sidebar-text);
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .nav-item:hover {
      background: var(--white-alpha-05);
      color: var(--white);
    }

    .nav-item.active {
      background: var(--sidebar-active-bg);
      color: var(--sidebar-active-text);
      border-left: 3px solid var(--sidebar-active-text);
    }

    .nav-item svg {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
    }

    .sidebar-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--gray-700);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--white);
      font-weight: 600;
      font-size: 16px;
    }

    .user-details {
      flex: 1;
    }

    .user-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--white);
    }

    .user-role {
      font-size: 12px;
      color: var(--gray-400);
    }

    .logout-btn {
      background: none;
      border: none;
      color: var(--gray-400);
      cursor: pointer;
      padding: 8px;
      border-radius: var(--radius-sm);
      transition: all 0.2s;
    }

    .logout-btn:hover {
      background: var(--white-alpha-10);
      color: var(--white);
    }

    .main-content {
      margin-left: 260px;
      padding: 32px;
      min-height: 100vh;
      background: var(--bg-main);
      transition: background 0.3s ease;
    }

    .page-header {
      margin-bottom: 32px;
    }

    .page-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--gray-900);
      margin-bottom: 8px;
    }


    /* ===== 대시보드 카드 ===== */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 24px;
      margin-bottom: 32px;
    }

    .stat-card {
      background: var(--white);
      border-radius: var(--radius);
      padding: 24px;
      box-shadow: var(--shadow);
    }

    .stat-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .stat-card-icon {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .stat-card-icon.blue {
      background: var(--primary-light);
      color: var(--primary);
    }

    .stat-card-icon.green {
      background: var(--success-light);
      color: var(--success);
    }

    .stat-card-icon.yellow {
      background: var(--warning-light);
      color: var(--warning);
    }

    .stat-card-icon svg {
      width: 24px;
      height: 24px;
    }

    .stat-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--gray-900);
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 14px;
      color: var(--gray-500);
    }

    /* ===== 콘텐츠 섹션 ===== */
    .content-section {
      background: var(--bg-card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 24px;
      transition: background 0.3s ease;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 24px;
      border-bottom: 1px solid var(--gray-200);
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gray-900);
    }

    .section-body {
      padding: 24px;
    }

    /* ===== 테이블 스타일 ===== */
    .table-container {
      overflow-x: auto;
      border-radius: var(--radius);
      border: 1px solid var(--border-default);
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--bg-card);
    }

    .data-table thead {
      background: var(--gray-50);
      border-bottom: 2px solid var(--border-default);
    }

    .data-table th {
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 14px;
      color: var(--gray-700);
      white-space: nowrap;
    }

    .data-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-default);
      font-size: 14px;
      color: var(--text-primary);
    }

    .data-table tbody tr:hover {
      background: var(--gray-50);
    }

    .data-table tbody tr:last-child td {
      border-bottom: none;
    }

    /* ===== 테마 설정 ===== */
    .theme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
    }

    .theme-card {
      border: 2px solid var(--border-default);
      border-radius: var(--radius-lg);
      padding: 20px;
      cursor: pointer;
      transition: all 0.25s ease;
      background: var(--bg-card);
      position: relative;
      overflow: hidden;
    }

    .theme-card:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .theme-card.active {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px var(--primary-alpha-20);
    }

    .theme-card.active::before {
      content: '';
      position: absolute;
      top: 12px;
      right: 12px;
      width: 24px;
      height: 24px;
      background: var(--primary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .theme-card.active::after {
      content: '✓';
      position: absolute;
      top: 14px;
      right: 18px;
      color: var(--white);
      font-size: 14px;
      font-weight: bold;
    }

    .theme-preview {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding: 12px;
      border-radius: var(--radius);
      background: var(--gray-100);
    }

    .theme-preview-sidebar {
      width: 40px;
      height: 60px;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .theme-preview-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .theme-preview-header {
      height: 12px;
      border-radius: 2px;
      width: 60%;
    }

    .theme-preview-card {
      flex: 1;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .theme-preview-btn {
      width: 40px;
      height: 16px;
      border-radius: 3px;
    }

    .theme-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .theme-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .theme-description {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .theme-colors {
      display: flex;
      gap: 6px;
      margin-top: 12px;
    }

    .theme-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid var(--white);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    /* ===== 이미지 관리 ===== */
    .slides-page {
      display: none;
    }

    .slides-page.show {
      display: block;
    }

    .upload-zone {
      border: 2px dashed var(--gray-300);
      border-radius: var(--radius);
      padding: 48px 24px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: var(--gray-50);
    }

    .upload-zone:hover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .upload-zone.dragover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .upload-icon {
      width: 64px;
      height: 64px;
      margin: 0 auto 16px;
      color: var(--gray-400);
    }

    .upload-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: 8px;
    }

    .upload-hint {
      font-size: 14px;
      color: var(--gray-500);
    }

    .upload-input {
      display: none;
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      margin-top: 24px;
    }

    .image-card {
      background: var(--white);
      border-radius: var(--radius);
      overflow: hidden;
      border: 1px solid var(--gray-200);
      transition: all 0.2s;
    }

    .image-card:hover {
      box-shadow: var(--shadow-md);
    }

    .image-preview {
      width: 100%;
      height: 180px;
      object-fit: cover;
      background: var(--gray-100);
    }

    .image-info {
      padding: 16px;
    }

    .image-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--gray-900);
      margin-bottom: 4px;
      word-break: break-all;
    }

    .image-meta {
      font-size: 12px;
      color: var(--gray-500);
      margin-bottom: 12px;
    }

    .image-actions {
      display: flex;
      gap: 8px;
    }

    .image-actions .btn {
      flex: 1;
    }

    /* ===== 탭 ===== */
    .tabs {
      display: flex;
      gap: 4px;
      padding: 4px;
      background: var(--gray-100);
      border-radius: var(--radius-sm);
      margin-bottom: 24px;
    }

    .tab {
      flex: 1;
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      color: var(--gray-600);
      background: none;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab:hover {
      color: var(--gray-900);
    }

    .tab.active {
      background: var(--white);
      color: var(--gray-900);
      box-shadow: var(--shadow-sm);
    }

    /* ===== 토스트 알림 ===== */
    .toast-container {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .toast {
      background: var(--gray-900);
      color: var(--white);
      padding: 16px 20px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .toast.success {
      background: var(--success);
    }

    .toast.error {
      background: var(--danger);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* ===== 모달 ===== */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: var(--overlay-bg);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-backdrop.show {
      display: flex;
    }

    .modal {
      background: var(--white);
      border-radius: var(--radius-lg);
      width: 100%;
      max-width: 480px;
      box-shadow: var(--shadow-lg);
    }

    .modal-header {
      display: flex;
      padding: 20px 24px;
      border-bottom: 1px solid var(--gray-200);
    }

    .modal-title {
      font-size: 18px;
      font-weight: 600;
    }

    .modal-body {
      padding: 24px;
    }

    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--gray-200);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    /* ===== 빈 상태 ===== */
    .empty-state {
      text-align: center;
      padding: 48px 24px;
    }

    .empty-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto 16px;
      color: var(--gray-300);
    }

    .empty-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--gray-700);
      margin-bottom: 8px;
    }

    .empty-description {
      font-size: 14px;
      color: var(--gray-500);
    }

    /* ===== 로딩 ===== */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--gray-200);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* ===== 층 번호 선택기 ===== */
    .floor-number-picker {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      background: var(--white);
      border: 1px solid var(--gray-300);
      border-radius: var(--radius-sm);
      padding: 8px 16px;
      min-width: 100px;
    }

    .floor-arrow {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: var(--gray-500);
      border-radius: 4px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floor-arrow:hover {
      background: var(--gray-100);
      color: var(--primary);
    }

    .floor-arrow:active {
      background: var(--primary-light);
      color: var(--primary);
    }

    .floor-number-display {
      font-size: 18px;
      font-weight: 600;
      color: var(--gray-900);
      min-width: 80px;
      text-align: center;
      padding: 4px 0;
    }

    /* ===== 청사도 편집기 ===== */
    .floor-element {
      position: absolute;
      cursor: move;
      pointer-events: all;
      border: 2px solid var(--primary);
      background: var(--primary-alpha-10);
      border-radius: 4px;
      min-width: 50px;
      min-height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s, background 0.2s;
      will-change: transform;
    }

    .floor-element.dragging {
      transition: none;
      z-index: 100;
      opacity: 0.9;
    }

    .floor-element:hover {
      border-color: var(--primary-dark);
      background: var(--primary-alpha-20);
      z-index: 10;
    }

    .floor-element.selected {
      border-color: var(--danger);
      background: var(--danger-alpha-20);
      z-index: 10;
    }

    .floor-element.text-element {
      padding: 4px 8px;
      font-size: 12px;
      color: var(--text-primary);
      background: var(--white-alpha-90);
      border: 1px solid var(--border-default);
    }

    .floor-element.icon-element {
      width: 30px;
      height: 30px;
      background: var(--white-alpha-90);
      border: 1px solid var(--border-default);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .floor-element.icon-element img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .current-location-element {
      position: absolute;
      cursor: move;
      pointer-events: all;
      border: 2px solid var(--current-location);
      background: var(--current-location-alpha-20);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s, background 0.2s;
      will-change: transform;
      min-width: 50px;
      min-height: 30px;
    }

    .current-location-element.dragging {
      transition: none;
      z-index: 100;
      opacity: 0.9;
    }

    .current-location-element:hover {
      border-color: var(--current-location-dark);
      background: var(--current-location-alpha-30);
      z-index: 10;
    }

    .current-location-element.selected {
      border-color: var(--danger);
      background: var(--danger-alpha-20);
      z-index: 10;
    }

    .current-location-element .label {
      padding: 4px 8px;
      font-size: 11px;
      font-weight: bold;
      color: var(--text-dark);
      background: var(--current-location);
      border-radius: 12px;
      white-space: nowrap;
    }

    .floor-element .delete-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--danger);
      color: var(--white);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      pointer-events: all;
      z-index: 20;
    }

    .floor-element .delete-btn:hover {
      background: var(--danger-dark);
    }

    .element-type-selector {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }

    .element-type-btn {
      flex: 1;
      padding: 16px;
      border: 2px solid var(--gray-300);
      border-radius: var(--radius-sm);
      background: var(--white);
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .element-type-btn:hover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .element-type-btn.selected {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .element-type-btn svg {
      width: 32px;
      height: 32px;
      margin: 0 auto 8px;
      display: block;
      color: var(--gray-600);
    }

    .element-type-btn.selected svg {
      color: var(--primary);
    }

    .icon-type-selector {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }

    .icon-type-btn {
      position: relative;
      padding: 12px;
      border: 2px solid var(--gray-300);
      border-radius: var(--radius-sm);
      background: var(--white);
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .icon-type-btn:hover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .icon-type-btn.selected {
      border-color: var(--primary);
      background: var(--primary-light);
      position: relative;
    }

    .icon-type-btn.selected::after {
      content: "✓";
      position: absolute;
      top: 4px;
      right: 4px;
      width: 18px;
      height: 18px;
      background: var(--primary);
      color: white;
      border-radius: 50%;
      font-size: 11px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-type-btn.selected span {
      color: var(--primary);
      font-weight: 600;
    }

    .icon-type-btn img {
      width: 32px;
      height: 32px;
      margin: 0 auto 8px;
      display: block;
    }

    .icon-type-btn span {
      font-size: 12px;
      color: var(--gray-700);
      display: block;
    }

    /* ===== 업로드 스텝 카드 ===== */
    .upload-step-card {
      background: var(--gradient-primary);
      border: 2px solid var(--primary);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 24px;
    }

    .upload-step-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .upload-step-number {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--primary);
      color: var(--white);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
    }

    .upload-step-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-800);
    }

    .upload-step-content {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .upload-floor-select {
      min-width: 200px;
      font-size: 15px;
      font-weight: 500;
    }

    .selected-floor-badge {
      background: var(--primary);
      color: var(--white);
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: fadeIn 0.3s ease;
    }

    .selected-floor-badge::before {
      content: "✓";
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* 업로드 옵션 컨테이너 */
    .upload-options-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
    }

    .upload-options-container.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .upload-option-card {
      background: var(--white);
      border: 2px solid var(--gray-200);
      border-radius: var(--radius);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      transition: all 0.2s;
    }

    .upload-option-card:hover {
      border-color: var(--primary);
      box-shadow: var(--shadow-md);
    }

    .upload-option-card.has-file {
      border-color: var(--success);
      background: var(--success-light);
    }

    .upload-option-icon {
      color: var(--gray-400);
    }

    .upload-option-card.has-file .upload-option-icon {
      color: var(--success);
    }

    .upload-option-info h4 {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-800);
      margin-bottom: 4px;
    }

    .upload-option-info p {
      font-size: 13px;
      color: var(--gray-500);
    }

    .upload-option-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .upload-file-input {
      display: none;
    }

    .upload-file-label {
      cursor: pointer;
      flex-shrink: 0;
    }

    .upload-file-name {
      font-size: 13px;
      color: var(--gray-500);
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .upload-file-name.selected {
      color: var(--success);
      font-weight: 500;
    }

    .upload-option-actions .btn-primary:disabled {
      background: var(--gray-300);
      cursor: not-allowed;
    }

    /* 업로드 플레이스홀더 */
    .upload-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 48px 24px;
      background: var(--gray-50);
      border: 2px dashed var(--gray-300);
      border-radius: var(--radius);
      color: var(--gray-400);
      text-align: center;
    }

    .upload-placeholder p {
      margin-top: 12px;
      font-size: 15px;
      color: var(--gray-500);
    }

    .upload-placeholder strong {
      color: var(--primary);
    }

    /* ===== 청사도 관리 2단 레이아웃 ===== */
    .floor-plan-layout {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 24px;
      min-height: calc(100vh - 200px);
    }

    .floor-plan-sidebar {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .floor-plan-main {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .floor-plan-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
      padding: 16px 20px;
      background: var(--white);
      border-radius: 12px 12px 0px 0px;
      box-shadow: var(--shadow);
    }

    .toolbar-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .toolbar-center {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-center .current-floor-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 24px;
      font-weight: 600;
      color: var(--text-primary);
      /* background: var(--primary-light); */
      padding: 8px 16px;
      /* border-radius: var(--radius-sm); */
      /* border: 1px solid var(--primary); */
    }

    .toolbar-center .current-floor-info .floor-icon {
      color: var(--primary);
    }

    .toolbar-right {
      display: flex;
      flex-direction: row;
      /* align-items: center; */
      gap: 8px;
      flex-wrap: wrap;
    }

    /* 드롭다운 버튼 스타일 */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .dropdown-toggle .dropdown-arrow {
      transition: transform 0.2s;
    }

    .dropdown.open .dropdown-toggle .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      min-width: 180px;
      background: var(--bg-card);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-lg);
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
    }

    .dropdown.open .dropdown-menu {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .dropdown-menu .dropdown-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      font-size: 14px;
      color: var(--text-primary);
      cursor: pointer;
      transition: background 0.15s;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .dropdown-menu .dropdown-item:hover {
      background: var(--primary-light);
      color: var(--primary);
    }

    .dropdown-menu .dropdown-item svg {
      flex-shrink: 0;
    }

    /* 토글 버튼 스타일 */
    .btn-toggle {
      padding: 8px 12px;
      border: 1px solid var(--border-default);
      background: var(--bg-card);
      color: var(--text-secondary);
      border-radius: var(--radius-sm);
      transition: all 0.2s;
    }

    .btn-toggle:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: var(--primary-light);
    }

    .btn-toggle.active {
      border-color: var(--primary);
      background: var(--primary);
      color: white;
    }

    .floor-plan-viewer {
      /* flex: 1; */
      background: var(--white);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .floor-plan-viewer-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
    }

    .floor-plan-viewer-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--gray-900);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .floor-plan-viewer-title .badge {
      background: var(--primary-light);
      color: var(--primary);
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }

    .floor-plan-viewer-body {
      padding: 20px;
      /* background: var(--gray-100); */
      overflow: auto;
      max-height: calc(100vh - 380px);
    }

    /* 층 관리 섹션 스타일 */
    .floor-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 12px;
    }

    /* + 층 추가 버튼 */
    .add-floor-toggle-btn {
      width: 100%;
      justify-content: center;
      padding: 10px;
      font-size: 13px;
      border-style: dashed;
      color: var(--text-secondary);
    }

    .add-floor-toggle-btn:hover {
      color: var(--primary);
      border-color: var(--primary);
      background: var(--primary-light);
    }

    /* 층 추가 UI 헤더 */
    .add-floor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    /* 층 번호 선택기 (가로 배치) */
    .floor-number-picker-row {
      margin-bottom: 12px;
    }

    .floor-number-picker-horizontal {
      display: flex;
      align-items: center;
      gap: 0;
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      background: var(--bg-card);
      width: 100%;
      height: 42px;
    }

    .floor-number-picker-horizontal .floor-number-display {
      flex: 1;
      text-align: left;
      padding: 0 12px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .floor-arrows-vertical {
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border-default);
    }

    .floor-arrow-sm {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 21px;
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.15s;
    }

    .floor-arrow-sm:first-child {
      border-bottom: 1px solid var(--border-default);
    }

    .floor-arrow-sm:hover {
      background: var(--primary-light);
      color: var(--primary);
    }

    .floor-list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s;
    }

    .floor-list-item:hover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .floor-list-item.selected {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .floor-list-item .floor-name {
      font-size: 14px;
      font-weight: 500;
      color: var(--gray-800);
    }

    .floor-list-item .floor-actions {
      display: flex;
      gap: 4px;
    }

    .floor-list-item .floor-actions .btn-icon,
    .floor-list-item .floor-actions .btn-icon-danger {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: transparent;
      border: none;
      color: var(--gray-500);
      cursor: pointer;
      transition: all 0.2s;
    }

    .floor-list-item .floor-actions .btn-icon:hover {
      background: var(--white);
      color: var(--primary);
    }

    .floor-list-item .floor-actions .btn-icon.delete:hover,
    .floor-list-item .floor-actions .btn-icon-danger:hover {
      background: var(--danger-light);
      color: var(--danger);
    }

    /* 파일 선택 영역 */
    .file-select-area {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--gray-50);
      border: 2px dashed var(--gray-300);
      border-radius: var(--radius-sm);
      transition: all 0.2s;
    }

    .file-select-area:hover {
      border-color: var(--primary);
      background: var(--primary-light);
    }

    .file-select-area .file-icon {
      width: 40px;
      height: 40px;
      background: var(--white);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--gray-400);
    }

    .file-select-area .file-info {
      flex: 1;
    }

    .file-select-area .file-info .file-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--gray-700);
      margin-bottom: 2px;
    }

    .file-select-area .file-info .file-name {
      font-size: 12px;
      color: var(--gray-500);
    }

    .file-select-area .file-info .file-name.selected {
      color: var(--success);
      font-weight: 500;
    }

    /* 섹션 카드 컴팩트 */
    .section-compact {
      background: var(--white);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .section-compact .section-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--gray-200);
    }

    .section-compact .section-header .section-title {
      font-size: 15px;
    }

    .section-compact .section-body {
      padding: 16px;
    }

    /* 버튼 그룹 */
    .btn-group {
      display: flex;
      gap: 8px;
    }

    .btn-group-vertical {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* 분리선 */
    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: var(--gray-300);
      margin: 0 4px;
    }

    /* ===== 이미지 리사이즈 모달 ===== */
    .image-resize-preview-container {
      background: #1a1a1a;
      border-radius: var(--radius);
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }

    .image-resize-canvas-wrapper {
      position: relative;
      width: 800px;
      height: 600px;
      overflow: hidden;
      background: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%) 50% / 20px 20px;
      border: 2px solid var(--border-default);
      border-radius: var(--radius-sm);
      cursor: grab;
    }

    .image-resize-canvas-wrapper:active {
      cursor: grabbing;
    }

    .image-resize-canvas-wrapper canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .image-resize-canvas-wrapper #imageResizePreview {
      position: absolute;
      max-width: none;
      max-height: none;
      user-select: none;
      -webkit-user-drag: none;
      display: none;
      /* canvas에만 렌더링하므로 숨김 */
    }

    .image-resize-controls {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      padding: 16px;
      background: var(--gray-50);
      border-radius: var(--radius);
    }

    .resize-control-group {
      flex: 1;
      min-width: 200px;
    }

    .resize-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .scale-slider {
      flex: 1;
      min-width: 100px;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--gray-200);
      border-radius: 3px;
      outline: none;
    }

    .scale-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s;
    }

    .scale-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .scale-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .scale-info {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .scale-info #scalePercentage {
      font-weight: 600;
      color: var(--primary);
    }


    /* 반응형 조정 */
    @media (max-width: 900px) {
      .image-resize-canvas-wrapper {
        width: 100%;
        height: auto;
        aspect-ratio: 800 / 600;
      }
    }

    /* ===== 콘텐츠 이미지 리사이즈 모달 (메인/홍보 화면용) ===== */
    .content-resize-preview-container {
      background: #1a1a1a;
      border-radius: var(--radius);
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      overflow: hidden;
    }

    .content-resize-canvas-wrapper {
      position: relative;
      width: 490px;
      /* 기본값, JavaScript에서 동적으로 변경됨 */
      height: 265px;
      /* 기본값, JavaScript에서 동적으로 변경됨 */
      overflow: hidden;
      background: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%) 50% / 20px 20px;
      border: 2px solid var(--border-default);
      border-radius: var(--radius-sm);
      cursor: grab;
    }

    .content-resize-canvas-wrapper:active {
      cursor: grabbing;
    }

    .content-resize-canvas-wrapper canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .content-resize-canvas-wrapper #contentResizePreview {
      position: absolute;
      max-width: none;
      max-height: none;
      user-select: none;
      -webkit-user-drag: none;
      display: none;
      /* canvas에만 렌더링하므로 숨김 */
    }

    /* 크롭 박스 스타일 */
    .crop-box {
      position: absolute;
      border: 2px solid #3b82f6;
      background: rgba(59, 130, 246, 0.1);
      cursor: move;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    .crop-box-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #3b82f6;
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      z-index: 11;
    }

    /* 모서리 핸들 */
    .crop-box-handle.nw {
      top: -6px;
      left: -6px;
      cursor: nw-resize;
    }

    .crop-box-handle.ne {
      top: -6px;
      right: -6px;
      cursor: ne-resize;
    }

    .crop-box-handle.sw {
      bottom: -6px;
      left: -6px;
      cursor: sw-resize;
    }

    .crop-box-handle.se {
      bottom: -6px;
      right: -6px;
      cursor: se-resize;
    }

    /* 가장자리 핸들 */
    .crop-box-handle.n {
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      cursor: n-resize;
    }

    .crop-box-handle.s {
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      cursor: s-resize;
    }

    .crop-box-handle.w {
      top: 50%;
      left: -6px;
      transform: translateY(-50%);
      cursor: w-resize;
    }

    .crop-box-handle.e {
      top: 50%;
      right: -6px;
      transform: translateY(-50%);
      cursor: e-resize;
    }

    .content-resize-controls {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      padding: 16px;
      background: var(--gray-50);
      border-radius: var(--radius);
    }

    .content-scale-info {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .content-scale-info #contentScalePercentage {
      font-weight: 600;
      color: var(--primary);
    }

    /* 썸네일 미리보기 */
    .thumbnail-preview-section {
      margin-top: 16px;
      padding: 16px;
      background: var(--gray-50);
      border-radius: var(--radius);
    }

    .thumbnail-preview-section h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: var(--text-primary);
    }

    .thumbnail-preview-grid {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    .thumbnail-preview-item {
      text-align: center;
    }

    .thumbnail-preview-item img {
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      background: #fff;
    }

    .thumbnail-preview-item span {
      display: block;
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    @media (max-width: 1100px) {
      .content-resize-canvas-wrapper {
        width: 100%;
        height: auto;
        aspect-ratio: 1920 / 1080;
      }
    }

    /* ===== 반응형 ===== */
    @media (max-width: 1200px) {
      .floor-plan-layout {
        grid-template-columns: 300px 1fr;
      }
    }

    @media (max-width: 1024px) {
      .floor-plan-layout {
        grid-template-columns: 1fr;
      }

      .floor-plan-viewer-body {
        max-height: 60vh;
      }
    }

    @media (max-width: 1024px) {
      .sidebar {
        transform: translateX(-100%);
        z-index: 1000;
        transition: transform 0.3s;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .main-content {
        margin-left: 0;
      }
    }

    /* ===== 콘텐츠 탭 스타일 ===== */
    .content-tabs {
      display: flex;
      gap: 8px;
      background: var(--bg-card);
      padding: 8px;
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
    }

    .content-tab {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px 20px;
      border: none;
      background: transparent;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .content-tab:hover {
      background: var(--gray-100);
      color: var(--text-primary);
    }

    .content-tab.active {
      background: var(--primary);
      color: white;
    }

    .content-tab.active svg {
      stroke: white;
    }

    .content-type-section {
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ===== 클라이언트 관리 페이지 스타일 ===== */
    .section-badge {
      background: var(--primary);
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 12px;
      margin-left: 8px;
    }

    .client-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
      gap: 16px;
    }

    .client-card {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius);
      padding: 16px;
      transition: all 0.2s ease;
    }

    .client-card:hover {
      box-shadow: var(--shadow-md);
      border-color: var(--primary);
    }

    .client-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .client-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--gray-400);
    }

    .status-dot.online {
      background: var(--success);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .status-text {
      font-size: 13px;
      font-weight: 500;
      color: var(--success);
    }

    .client-id-badge {
      font-family: 'SF Mono', 'Consolas', monospace;
      font-size: 11px;
      padding: 4px 8px;
      background: var(--primary-light);
      color: var(--primary);
      border-radius: 4px;
    }

    .client-body {
      margin-bottom: 12px;
    }

    .client-alias-row {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .client-alias-row .form-input {
      flex: 1;
      font-size: 13px;
      padding: 8px 12px;
    }

    .client-info {
      background: var(--bg-primary);
      border-radius: var(--radius-sm);
      padding: 12px;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-light);
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: var(--text-secondary);
    }

    .info-value {
      color: var(--text-primary);
      font-family: 'SF Mono', 'Consolas', monospace;
      font-size: 11px;
    }

    .client-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .client-actions .btn {
      flex: 1;
      min-width: 80px;
    }

    .server-status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
    }

    .server-status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-light);
    }

    .server-status-item .status-label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .server-status-item .status-value code {
      font-family: 'SF Mono', 'Consolas', monospace;
      font-size: 12px;
      background: var(--gray-800);
      color: var(--success);
      padding: 4px 8px;
      border-radius: 4px;
    }

    .page-actions {
      display: flex;
      gap: 8px;
    }

    /* 반응형 클라이언트 카드 */
    @media (max-width: 768px) {
      .client-list {
        grid-template-columns: 1fr;
      }

      .client-actions {
        flex-direction: column;
      }

      .client-actions .btn {
        flex: none;
        width: 100%;
      }

      .page-actions {
        flex-wrap: wrap;
      }

      .page-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
    }
  </style>
  <script src="/static/js/auth-router.js"></script>
</head>

<body>
  <!-- 로그인 페이지 -->
  <div class="login-container" id="loginPage">
    <div class="login-card">
      <div class="login-logo">
        <svg width="175" height="28" viewBox="0 0 175 28" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M63.3774 25.0235L55.0908 2.98828H59.3123L66.2587 21.4199H67.3196L74.266 2.98828H78.4874L70.2009 25.0235H63.3774Z"
            fill="#151419" />
          <path d="M86.3832 2.98828V25.0235H82.4409V2.98828H86.3832Z" fill="#151419" />
          <path
            d="M112.952 2.98828V6.5918H95.8648V12.4895H112.561V16.093H95.8648V21.4311H113.744V25.0346H91.9114V2.98828H112.952Z"
            fill="#151419" />
          <path
            d="M123.215 25.0235L115.71 2.98828H119.931L126.208 21.4199H127.079L130.317 12.2433L127.157 2.98828H131.378L137.655 21.4199H138.481L144.757 2.98828H148.979L141.474 25.0235H134.651L132.439 18.4543L130.027 25.0235H123.204H123.215Z"
            fill="#151419" />
          <path
            d="M162.994 2.98828C170.689 2.98828 174.989 8.2145 174.989 14.5822C174.989 20.9499 170.689 26.1649 162.994 26.1649C155.3 26.1649 150.956 20.9387 150.956 14.5822C150.956 8.22569 155.255 2.98828 162.994 2.98828ZM171.047 14.5822C171.047 9.7141 168.556 6.55823 162.994 6.55823C157.433 6.55823 154.909 9.72529 154.909 14.5822C154.909 19.4391 157.399 22.6062 162.994 22.6062C168.59 22.6062 171.047 19.4391 171.047 14.5822Z"
            fill="#151419" />
          <path
            d="M33.8609 0C27.0262 0 22.4139 3.36851 20.426 8.19185L14.775 23.1431H13.4907L5.1037 0.884093H0L10.0064 27.4964H18.2594L24.4017 10.9448C24.4017 10.9448 26.4343 4.29736 33.8609 4.29736C40.5839 4.29736 43.5881 8.1247 43.5881 14C43.5881 19.8753 40.5839 23.7026 33.8609 23.7026C30.0973 23.7026 27.5064 22.5164 25.9317 20.4572L24.2454 24.9337C26.6465 26.8473 29.8628 28 33.8497 28C43.1414 28 48.3456 21.6882 48.3456 14C48.3456 6.31175 43.1637 0 33.8609 0Z"
            fill="#151419" />
        </svg>
      </div>
      <h1 class="login-title">관리자 로그인</h1>
      <!-- <p class="login-subtitle">Viewo 관리 시스템에 접속하세요</p> -->

      <div class="login-error" id="loginError">
        아이디 또는 비밀번호가 올바르지 않습니다.
      </div>

      <form id="loginForm">
        <div class="form-group">
          <label class="form-label" for="username">아이디</label>
          <input type="text" id="username" class="form-input" placeholder="아이디를 입력하세요" required />
        </div>
        <div class="form-group">
          <label class="form-label" for="password">비밀번호</label>
          <input type="password" id="password" class="form-input" placeholder="비밀번호를 입력하세요" required />
        </div>
        <button type="submit" class="btn btn-primary" id="loginBtn">
          로그인
        </button>
      </form>
    </div>
  </div>

  <!-- 대시보드 -->
  <div class="dashboard" id="dashboard">
    <!-- 사이드바 -->
    <aside class="sidebar">
      <div class="sidebar-logo">
        <svg width="175" height="28" viewBox="0 0 175 28" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M63.3774 25.0235L55.0908 2.98828H59.3123L66.2587 21.4199H67.3196L74.266 2.98828H78.4874L70.2009 25.0235H63.3774Z"
            fill="#ffffff" />
          <path d="M86.3832 2.98828V25.0235H82.4409V2.98828H86.3832Z" fill="#ffffff" />
          <path
            d="M112.952 2.98828V6.5918H95.8648V12.4895H112.561V16.093H95.8648V21.4311H113.744V25.0346H91.9114V2.98828H112.952Z"
            fill="#ffffff" />
          <path
            d="M123.215 25.0235L115.71 2.98828H119.931L126.208 21.4199H127.079L130.317 12.2433L127.157 2.98828H131.378L137.655 21.4199H138.481L144.757 2.98828H148.979L141.474 25.0235H134.651L132.439 18.4543L130.027 25.0235H123.204H123.215Z"
            fill="#ffffff" />
          <path
            d="M162.994 2.98828C170.689 2.98828 174.989 8.2145 174.989 14.5822C174.989 20.9499 170.689 26.1649 162.994 26.1649C155.3 26.1649 150.956 20.9387 150.956 14.5822C150.956 8.22569 155.255 2.98828 162.994 2.98828ZM171.047 14.5822C171.047 9.7141 168.556 6.55823 162.994 6.55823C157.433 6.55823 154.909 9.72529 154.909 14.5822C154.909 19.4391 157.399 22.6062 162.994 22.6062C168.59 22.6062 171.047 19.4391 171.047 14.5822Z"
            fill="#ffffff" />
          <path
            d="M33.8609 0C27.0262 0 22.4139 3.36851 20.426 8.19185L14.775 23.1431H13.4907L5.1037 0.884093H0L10.0064 27.4964H18.2594L24.4017 10.9448C24.4017 10.9448 26.4343 4.29736 33.8609 4.29736C40.5839 4.29736 43.5881 8.1247 43.5881 14C43.5881 19.8753 40.5839 23.7026 33.8609 23.7026C30.0973 23.7026 27.5064 22.5164 25.9317 20.4572L24.2454 24.9337C26.6465 26.8473 29.8628 28 33.8497 28C43.1414 28 48.3456 21.6882 48.3456 14C48.3456 6.31175 43.1637 0 33.8609 0Z"
            fill="#ffffff" />
        </svg>
      </div>

      <nav class="sidebar-nav">
        <div class="nav-section">
          <div class="nav-section-title">메뉴</div>
          <a href="#dashboard" class="nav-item active" data-page="dashboard">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
            <span>대시보드</span>
          </a>
          <a href="#slides" class="nav-item" data-page="slides">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <span>콘텐츠 관리</span>
          </a>
          <a href="#departments" class="nav-item" data-page="departments">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
            </svg>
            <span>부서 관리</span>
          </a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">청사도 관리</div>
          <a href="#buildings" class="nav-item" data-page="buildings">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
            </svg>
            <span>건물 관리</span>
          </a>
          <a href="#floor-plan" class="nav-item" data-page="floor-plan">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
            </svg>
            <span>청사도 관리</span>
          </a>
        </div>

        <div class="nav-section">
          <div class="nav-section-title">시스템</div>
          <a href="#clients" class="nav-item" data-page="clients">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
            <span>클라이언트 관리</span>
          </a>
          <a href="#settings" class="nav-item" data-page="settings">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            <span>시스템 설정</span>
          </a>
        </div>
      </nav>

      <div class="sidebar-footer">
        <div class="user-info">
          <div class="user-avatar" id="userAvatar">관</div>
          <div class="user-details">
            <div class="user-name" id="userName">관리자</div>
            <div class="user-role">Administrator</div>
          </div>
          <button class="logout-btn" id="logoutBtn" title="로그아웃">
            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
            </svg>
          </button>
        </div>
      </div>
    </aside>

    <!-- 메인 콘텐츠 -->
    <main class="main-content">
      <!-- 대시보드 페이지 -->
      <div class="dashboard-page" id="dashboardPage">
        <div class="page-header">
          <h1 class="page-title">대시보드</h1>
        </div>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon blue">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="slideCount">0</div>
            <div class="stat-label">슬라이드 이미지</div>
          </div>

          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon green">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="floorCount">0</div>
            <div class="stat-label">층 정보</div>
          </div>

          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon yellow">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="deptCount">0</div>
            <div class="stat-label">부서 정보</div>
          </div>
        </div>

        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">최근 활동</h2>
          </div>
          <div class="section-body">
            <div class="empty-state">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round"
                  d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <h3 class="empty-title">최근 활동이 없습니다</h3>
              <p class="empty-description">
                시스템을 사용하면 활동 내역이 여기에 표시됩니다.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- 콘텐츠 관리 페이지 -->
      <div class="slides-page" id="slidesPage">
        <div class="page-header">
          <h1 class="page-title">콘텐츠 관리</h1>
        </div>

        <!-- 탭 네비게이션 -->
        <div class="content-tabs" style="margin-bottom: 24px;">
          <button class="content-tab active" data-content-type="dashboard">
            <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
              style="margin-right: 8px;">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
            메인 화면
          </button>
          <button class="content-tab" data-content-type="pr">
            <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
              style="margin-right: 8px;">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z" />
            </svg>
            홍보 화면
          </button>
        </div>

        <!-- 메인 화면(대시보드) 이미지 섹션 -->
        <div id="dashboardImagesSection" class="content-type-section">
          <div class="content-section">
            <div class="section-header">
              <h2 class="section-title">메인 화면 이미지 업로드</h2>
            </div>
            <div class="section-body">
              <div class="upload-zone" id="dashboardUploadZone"
                onclick="document.getElementById('dashboardFileInput').click()">
                <svg class="upload-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" />
                </svg>
                <p class="upload-text">클릭하거나 파일을 드래그하세요</p>
                <p class="upload-hint">
                  JPG, PNG, GIF, WebP 형식 지원 (최대 10MB)
                </p>
              </div>
              <input type="file" id="dashboardFileInput" class="upload-input" accept="image/*" multiple />
            </div>
          </div>

          <div class="content-section">
            <div class="section-header">
              <h2 class="section-title">등록된 메인 화면 이미지</h2>
              <button class="btn btn-secondary btn-sm" onclick="loadDashboardImages()">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                새로고침
              </button>
            </div>
            <div class="section-body">
              <div class="image-grid" id="dashboardImageGrid">
                <!-- 대시보드 이미지 카드들이 여기에 동적으로 추가됨 -->
              </div>
            </div>
          </div>
        </div>

        <!-- 홍보 화면(PR) 이미지 섹션 -->
        <div id="prImagesSection" class="content-type-section" style="display: none;">
          <div class="content-section">
            <div class="section-header">
              <h2 class="section-title">홍보 화면 이미지 업로드</h2>
            </div>
            <div class="section-body">
              <div class="upload-zone" id="prUploadZone" onclick="document.getElementById('prFileInput').click()">
                <svg class="upload-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" />
                </svg>
                <p class="upload-text">클릭하거나 파일을 드래그하세요</p>
                <p class="upload-hint">
                  JPG, PNG, GIF, WebP 형식 지원 (최대 10MB)
                </p>
              </div>
              <input type="file" id="prFileInput" class="upload-input" accept="image/*" multiple />
            </div>
          </div>

          <div class="content-section">
            <div class="section-header">
              <h2 class="section-title">등록된 홍보 화면 이미지</h2>
              <button class="btn btn-secondary btn-sm" onclick="loadPrImages()">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                새로고침
              </button>
            </div>
            <div class="section-body">
              <div class="image-grid" id="prImageGrid">
                <!-- 홍보 이미지 카드들이 여기에 동적으로 추가됨 -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 건물 관리 페이지 -->
      <div class="slides-page" id="buildingsPage">
        <div class="page-header">
          <h1 class="page-title">건물 관리</h1>
        </div>

        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">새 건물 생성</h2>
          </div>
          <div class="section-body">
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 16px; align-items: end;">
              <div>
                <label class="form-label">건물 이름</label>
                <input type="text" id="newBuildingName" class="form-input" placeholder="예: 본관" />
              </div>
              <button class="btn btn-primary" id="createBuildingBtn">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                </svg>
                건물 생성
              </button>
            </div>
          </div>
        </div>

        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">등록된 건물</h2>
            <div style="display: flex; gap: 8px;">
              <button class="btn btn-secondary btn-sm" id="migrateDataBtn" title="기존 데이터 가져오기">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                </svg>
                기존 데이터 가져오기
              </button>
              <button class="btn btn-secondary btn-sm" id="refreshBuildingsBtn">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                새로고침
              </button>
            </div>
          </div>
          <div class="section-body">
            <div class="image-grid" id="buildingsGrid">
              <!-- 건물 카드들이 여기에 동적으로 추가됨 -->
            </div>
          </div>
        </div>
      </div>

      <!-- 청사도 관리 페이지 -->
      <div class="slides-page" id="floorPlanPage">
        <div class="page-header">
          <h1 class="page-title">청사도 관리</h1>
        </div>

        <div class="floor-plan-layout">
          <!-- 좌측 사이드바: 건물/층 선택 및 층 관리 -->
          <div class="floor-plan-sidebar">
            <!-- 건물 및 층 선택 섹션 -->
            <div class="section-compact">
              <div class="section-header">
                <h2 class="section-title">건물 선택</h2>
              </div>
              <div class="section-body">
                <div class="form-group" style="margin-bottom: 0;">
                  <select id="buildingSelect" class="form-input">
                    <option value="">건물을 선택하세요</option>
                  </select>
                </div>
              </div>
            </div>

            <!-- 층 관리 섹션 -->
            <div class="section-compact" id="floorManagementSection" style="display: none;">
              <div class="section-header">
                <h2 class="section-title">층 관리</h2>
              </div>
              <div class="section-body">
                <!-- 층 목록 -->
                <div class="form-group">
                  <label class="form-label">등록된 층</label>
                  <div class="floor-list" id="floorList">
                    <!-- 층 목록이 동적으로 추가됨 -->
                  </div>
                  <!-- + 층 추가 버튼 -->
                  <button class="btn btn-outline add-floor-toggle-btn" id="addFloorToggleBtn"
                    onclick="toggleAddFloorUI()">
                    <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                    </svg>
                    층 추가
                  </button>
                </div>

                <!-- 층 선택 드롭다운 (숨김) -->
                <select id="floorSelect" class="form-input" style="display: none;" disabled>
                  <option value="">층을 선택하세요</option>
                </select>

                <!-- 새 층 추가 UI (토글) -->
                <div id="addFloorUI"
                  style="display: none; border-top: 1px solid var(--gray-200); padding-top: 16px; margin-top: 16px;">
                  <div class="add-floor-header">
                    <label class="form-label" style="margin-bottom: 0;">새 층 추가</label>
                    <button class="btn-icon" onclick="toggleAddFloorUI()" title="닫기">
                      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  <div class="floor-number-picker-row">
                    <div class="floor-number-picker-horizontal" id="floorNumberPicker">
                      <span class="floor-number-display" id="floorNumberDisplay">1층</span>
                      <input type="hidden" id="newFloorNumber" value="1" />
                      <div class="floor-arrows-vertical">
                        <button type="button" class="floor-arrow-sm" id="floorUpBtn">
                          <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2.5"
                            viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
                          </svg>
                        </button>
                        <button type="button" class="floor-arrow-sm" id="floorDownBtn">
                          <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2.5"
                            viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                          </svg>
                        </button>
                      </div>
                    </div>
                  </div>

                  <!-- 파일 선택 영역 -->
                  <div class="file-select-area" onclick="document.getElementById('newFloorImage').click()">
                    <div class="file-icon">
                      <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round"
                          d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                      </svg>
                    </div>
                    <div class="file-info">
                      <div class="file-label">청사도 이미지</div>
                      <div class="file-name" id="selectedFileName">파일을 선택하세요</div>
                    </div>
                    <button class="btn btn-outline btn-sm"
                      onclick="event.stopPropagation(); document.getElementById('newFloorImage').click()">
                      선택
                    </button>
                  </div>
                  <input type="file" id="newFloorImage" style="display: none;" accept="image/*,.svg" />

                  <button class="btn btn-primary btn-lg" id="addFloorBtn" style="width: 100%; margin-top: 12px;">
                    <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                    </svg>
                    층 추가
                  </button>
                </div>
              </div>
            </div>

            <!-- JSON 불러오기 (사이드바 하단) -->
            <!-- <div class="section-compact" id="jsonImportSection" style="display: none;">
              <div class="section-header">
                <h2 class="section-title">데이터 가져오기</h2>
              </div>
              <div class="section-body">
                <input type="file" id="importJsonInput" accept=".json" style="display: none;" />
                <button class="btn btn-outline btn-md" id="importJsonBtn" style="width: 100%;">
                  <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round"
                      d="M9 8.25H7.5a2.25 2.25 0 00-2.25 2.25v9a2.25 2.25 0 002.25 2.25h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25H15m0-3l-3-3m0 0l-3 3m3-3V15" />
                  </svg>
                  JSON 파일 불러오기
                </button>
              </div>
            </div> -->
          </div>

          <!-- 우측 메인 영역: 평면도 편집기 -->
          <div class="floor-plan-main">
            <!-- 선택 안내 또는 편집기 -->
            <div id="editorPlaceholder" class="floor-plan-viewer">
              <div class="floor-plan-viewer-body"
                style="display: flex; align-items: center; justify-content: center; min-height: 400px;">
                <div class="empty-state">
                  <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round"
                      d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                  </svg>
                  <h3 class="empty-title">청사도를 선택하세요</h3>
                  <p class="empty-description">좌측에서 건물과 층을 선택하여 청사도를 편집하세요.</p>
                </div>
              </div>
            </div>

            <!-- 에디터 영역 (숨김) -->
            <div id="editorSection" style="display: none;">
              <!-- 툴바 -->
              <div class="floor-plan-toolbar">
                <!-- 좌측: 편집/제어 -->
                <div class="toolbar-left">
                  <button class="btn btn-primary btn-md" id="addElementBtn">
                    <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round"
                        d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
                    </svg>
                    요소 편집
                  </button>
                  <button class="btn btn-toggle" id="toggleCurrentLocationBtn" title="현위치 마커 표시/숨기기">
                    <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" />
                      <path stroke-linecap="round" stroke-linejoin="round"
                        d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z" />
                    </svg>
                  </button>
                </div>

                <!-- 중앙: 현재 층 정보 -->
                <div class="toolbar-center">
                  <div class="current-floor-info">
                    <svg class="floor-icon" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"
                      viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round"
                        d="M3.75 21h16.5M4.5 3h15M5.25 3v18m13.5-18v18M9 6.75h1.5m-1.5 3h1.5m-1.5 3h1.5m3-6H15m-1.5 3H15m-1.5 3H15M9 21v-3.375c0-.621.504-1.125 1.125-1.125h3.75c.621 0 1.125.504 1.125 1.125V21" />
                    </svg>
                    <span id="toolbarFloorInfo">층 정보</span>
                  </div>
                </div>

                <!-- 우측: 저장/내보내기 -->
                <div class="toolbar-right">
                  <div class="dropdown" id="exportDropdown">
                    <button class="btn btn-outline btn-md dropdown-toggle" onclick="toggleExportDropdown()">
                      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round"
                          d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                      </svg>
                      내보내기
                      <svg class="dropdown-arrow" width="12" height="12" fill="none" stroke="currentColor"
                        stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                      </svg>
                    </button>
                    <div class="dropdown-menu">
                      <button class="dropdown-item" id="exportJsonBtn">
                        <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"
                          viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round"
                            d="M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5" />
                        </svg>
                        좌표 데이터 내보내기
                      </button>
                      <button class="dropdown-item" id="exportImageBtn">
                        <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"
                          viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round"
                            d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
                        </svg>
                        이미지 내보내기
                      </button>
                    </div>
                  </div>
                  <button class="btn btn-primary btn-lg" id="saveFloorBtn">
                    <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                    </svg>
                    저장
                  </button>
                </div>
              </div>

              <!-- 평면도 뷰어 -->
              <div class="floor-plan-viewer">
                <!-- <div class="floor-plan-viewer-header">
                    <div class="floor-plan-viewer-title">
                      <span id="currentFloorTitle">청사도</span>
                      <span class="badge" id="currentFloorBadge">1층</span>
                    </div> -->
              </div>
              <div class="floor-plan-viewer-body">
                <div id="floorPlanCanvas"
                  style="position: relative; display: inline-block; background: var(--white); border: 2px solid var(--gray-300); border-radius: var(--radius-sm);">
                  <img id="floorPlanImage" style="display: block; width: 100%; height: 100%;" crossorigin="anonymous" />
                  <div id="floorPlanElements"
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                    <!-- 요소들이 여기에 동적으로 추가됨 -->
                  </div>
                  <div id="currentLocationElement"
                    style="position: absolute; top: 0; left: 0; pointer-events: none; display: none;">
                    <!-- currentLocation이 여기에 표시됨 -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>


        <!-- 하위호환: 기존 newFloorSection은 숨김 -->
        <div id="newFloorSection" style="display: none;"></div>
      </div>

      <!-- 클라이언트 관리 페이지 -->
      <div class="slides-page" id="clientsPage">
        <div class="page-header">
          <h1 class="page-title">클라이언트 관리</h1>
          <div class="page-actions">
            <button class="btn btn-secondary" onclick="refreshClientList()">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
                style="margin-right: 6px;">
                <path stroke-linecap="round" stroke-linejoin="round"
                  d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              새로고침
            </button>
            <button class="btn btn-warning" onclick="resetAllIndexedDB()">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
                style="margin-right: 6px;">
                <path stroke-linecap="round" stroke-linejoin="round"
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
              전체 초기화
            </button>
            <button class="btn btn-primary" onclick="syncAllClients()">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
                style="margin-right: 6px;">
                <path stroke-linecap="round" stroke-linejoin="round"
                  d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
              전체 동기화
            </button>
          </div>
        </div>

        <!-- 연결 상태 카드 -->
        <div class="stats-grid" style="margin-bottom: 24px;">
          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon green">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="connectedClientCount">0</div>
            <div class="stat-label">연결된 클라이언트</div>
          </div>

          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon blue">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="dataVersion">0</div>
            <div class="stat-label">데이터 버전</div>
          </div>

          <div class="stat-card">
            <div class="stat-card-header">
              <div class="stat-card-icon yellow">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </div>
            </div>
            <div class="stat-value" id="lastUpdateTime">-</div>
            <div class="stat-label">마지막 업데이트</div>
          </div>
        </div>

        <!-- 클라이언트 목록 -->
        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">연결된 클라이언트</h2>
            <span class="section-badge" id="clientCountBadge">0</span>
          </div>
          <div class="section-body">
            <div class="client-list" id="clientList">
              <!-- 클라이언트 카드가 동적으로 추가됨 -->
              <div class="empty-state">
                <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                </svg>
                <h3 class="empty-title">연결된 클라이언트가 없습니다</h3>
                <p class="empty-description">Viewo 클라이언트 앱이 실행되면 여기에 표시됩니다.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- 서버 상태 정보 -->
        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">서버 동기화 상태</h2>
          </div>
          <div class="section-body">
            <div class="server-status-grid">
              <div class="server-status-item">
                <span class="status-label">SSE 엔드포인트</span>
                <span class="status-value">
                  <code>/api/v1/sse/events</code>
                </span>
              </div>
              <div class="server-status-item">
                <span class="status-label">동기화 API</span>
                <span class="status-value">
                  <code>/api/v1/sync/version</code>
                </span>
              </div>
              <div class="server-status-item">
                <span class="status-label">클라이언트 관리 API</span>
                <span class="status-value">
                  <code>/api/v1/clients</code>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 설정 페이지 -->
      <div class="slides-page" id="settingsPage">
        <div class="page-header">
          <h1 class="page-title">시스템 설정</h1>
        </div>

        <!-- 테마 설정 섹션 -->
        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">테마 설정</h2>
          </div>
          <div class="section-body">
            <p style="margin-bottom: 16px; color: var(--text-secondary);">
              관리자 페이지의 테마를 선택하세요. 변경 사항은 즉시 적용됩니다.
            </p>
            <div class="theme-grid" id="themeGrid">
              <!-- 테마 카드가 동적으로 추가됨 -->
            </div>
          </div>
        </div>

        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">API 정보</h2>
          </div>
          <div class="section-body">
            <p style="margin-bottom: 16px;">
              <strong>API 버전:</strong> v1
            </p>
            <p style="margin-bottom: 16px;">
              <strong>API 문서:</strong>
              <a href="/docs" target="_blank" style="color: var(--primary);">/docs</a>
            </p>
            <p>
              <strong>서버 상태:</strong>
              <span style="color: var(--success);">정상 운영 중</span>
            </p>
          </div>
        </div>
      </div>

      <!-- 부서 관리 페이지 -->
      <div class="slides-page" id="departmentsPage">
        <div class="page-header">
          <h1 class="page-title">부서 관리</h1>
          <button class="btn btn-primary" onclick="loadDepartments()">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            새로고침
          </button>
        </div>

        <div class="content-section">
          <div class="section-header">
            <h2 class="section-title">부서 목록</h2>

            <div style="display: flex; gap: 16px; align-items: center;">
              <div style="display: flex; align-items: center; gap: 4px; margin-right: 16px;">
                <select id="itemsPerPageSelect" class="form-input" style="width: 100px; padding: 6px 12px;"
                  onchange="changeItemsPerPage()">
                  <option value="10">10개씩</option>
                  <option value="25">25개씩</option>
                  <option value="50" selected>50개씩</option>
                  <option value="100">100개씩</option>
                  <option value="200">200개씩</option>
                </select>
                <span style="font-size: 14px; color: var(--text-secondary);">보기</span>
              </div>
              <input type="text" id="departmentSearchInput" class="form-input" placeholder="부서명, 건물, 층으로 검색..."
                style="width: 300px;" />
              <button class="btn btn-primary btn-sm" onclick="filterDepartments()">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                검색
              </button>

            </div>
          </div>
          <div class="section-body">
            <div class="table-container">
              <table class="data-table">
                <thead>
                  <tr>
                    <th>건물</th>
                    <th>층</th>
                    <th>부서</th>
                    <th>팀</th>
                    <th>직책</th>
                    <th>업무</th>
                  </tr>
                </thead>
                <tbody id="departmentsTableBody">
                  <tr>
                    <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                      데이터를 불러오는 중...
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div id="departmentsPagination" style="margin-top: 20px; display: none;"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- 삭제 확인 모달 -->
  <div class="modal-backdrop" id="deleteModal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title">이미지 삭제</h3>
      </div>
      <div class="modal-body">
        <p>이 이미지를 삭제하시겠습니까? 삭제된 이미지는 복구할 수 없습니다.</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelDeleteBtn">취소</button>
        <button class="btn btn-danger" id="confirmDeleteBtn">삭제</button>
      </div>
    </div>
  </div>

  <!-- 요소 편집 모달 -->
  <div class="modal-backdrop" id="addElementModal">
    <div class="modal" style="max-width: 600px;">
      <div class="modal-header">
        <h3 class="modal-title">요소 편집</h3>
        <button class="btn btn-danger btn-sm" id="resetElementsBtn" style="margin-left: auto;">
          <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
            style="margin-right: 4px;">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
          </svg>
          요소 초기화
        </button>
      </div>
      <div class="modal-body">
        <div class="element-type-selector">
          <div class="element-type-btn" data-type="text">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h7" />
            </svg>
            <span>텍스트</span>
          </div>
          <div class="element-type-btn" data-type="icon">
            <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <span>아이콘</span>
          </div>
        </div>
        <div id="textElementForm" style="display: none;">
          <div class="form-group">
            <label class="form-label">텍스트 내용</label>
            <input type="text" id="elementText" class="form-input" placeholder="텍스트를 입력하세요" />
          </div>
          <div class="form-group">
            <label class="form-label">폰트 크기</label>
            <input type="number" id="elementFontSize" class="form-input" value="12" min="8" max="48" />
          </div>
          <div class="form-group">
            <label class="form-label">색상</label>
            <input type="color" id="elementColor" class="form-input" value="#333333" />
          </div>
        </div>
        <div id="iconElementForm" style="display: none;">
          <div class="form-group">
            <label class="form-label">아이콘 타입 선택</label>
            <div class="icon-type-selector" id="iconTypeSelector">
              <!-- 아이콘 타입 버튼들이 여기에 동적으로 추가됨 -->
            </div>
            <button type="button" class="btn btn-secondary" style="margin-top: 12px; width: 100%;"
              id="addNewIconTypeBtn">
              <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
                style="margin-right: 6px;">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
              </svg>
              새 아이콘 타입 추가
            </button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelAddElementBtn">취소</button>
        <button class="btn btn-primary" id="confirmAddElementBtn">추가</button>
      </div>
    </div>
  </div>

  <!-- 아이콘 타입 추가 모달 -->
  <div class="modal-backdrop" id="addIconTypeModal">
    <div class="modal" style="max-width: 450px;">
      <div class="modal-header">
        <h3 class="modal-title">새 아이콘 타입 추가</h3>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="form-label">아이콘 라벨 (표시 이름)</label>
          <input type="text" id="newIconTypeLabel" class="form-input" placeholder="예: 엘리베이터, 계단" />
        </div>
        <div class="form-group">
          <label class="form-label">아이콘 이미지</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="file" id="newIconTypeFile" accept=".svg,.png,.jpg,.jpeg" style="display: none;" />
            <button type="button" class="btn btn-secondary" id="selectIconFileBtn">파일 선택</button>
            <span id="selectedIconFileName" style="font-size: 13px; color: var(--gray-500);">파일을 선택하세요</span>
          </div>
          <div id="iconPreviewContainer" style="margin-top: 12px; display: none;">
            <img id="iconPreview"
              style="max-width: 64px; max-height: 64px; border: 1px solid var(--gray-200); border-radius: 8px; padding: 8px;" />
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelAddIconTypeBtn">취소</button>
        <button class="btn btn-primary" id="confirmAddIconTypeBtn">추가</button>
      </div>
    </div>
  </div>

  <!-- 이미지 리사이즈 모달 -->
  <div class="modal-backdrop" id="imageResizeModal">
    <div class="modal" style="max-width: 900px;">
      <div class="modal-header">
        <h3 class="modal-title">청사도 이미지 조정</h3>
        <span style="font-size: 13px; color: var(--text-secondary); margin-left: auto;">최종 크기: 800 × 600px</span>
      </div>
      <div class="modal-body" style="padding: 16px;">
        <!-- 미리보기 영역 -->
        <div class="image-resize-preview-container">
          <div class="image-resize-canvas-wrapper" id="imageResizeCanvasWrapper">
            <canvas id="imageResizeCanvas" width="800" height="600"></canvas>
            <img id="imageResizePreview" draggable="false" />
          </div>
        </div>

        <!-- 컨트롤 영역 -->
        <div class="image-resize-controls">
          <div class="resize-control-group">
            <label class="form-label" style="margin-bottom: 8px;">이미지 크기 조정</label>
            <div class="resize-buttons">
              <button type="button" class="btn btn-secondary btn-sm" id="zoomOutBtn" title="축소">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" />
                </svg>
                축소
              </button>
              <input type="range" id="imageScaleSlider" min="10" max="300" value="100" class="scale-slider" />
              <button type="button" class="btn btn-secondary btn-sm" id="zoomInBtn" title="확대">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" />
                </svg>
                확대
              </button>
              <button type="button" class="btn btn-outline btn-sm" id="fitToCanvasBtn" title="캔버스에 맞추기">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round"
                    d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" />
                </svg>
                맞춤
              </button>
            </div>
            <div class="scale-info">
              <span id="scalePercentage">100%</span>
              <span id="imageDimensions">- × - px</span>
            </div>
          </div>

        </div>

        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; text-align: center;">
          💡 이미지를 드래그하여 위치를 조정할 수 있습니다.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelImageResizeBtn">취소</button>
        <button class="btn btn-primary" id="confirmImageResizeBtn">
          <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
            style="margin-right: 4px;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
          </svg>
          적용하기
        </button>
      </div>
    </div>
  </div>

  <!-- 콘텐츠 이미지 리사이즈 모달 (메인/홍보 화면용) -->
  <div class="modal-backdrop" id="contentResizeModal">
    <div class="modal" style="max-width: 1050px;">
      <div class="modal-header">
        <h3 class="modal-title" id="contentResizeModalTitle">이미지 조정</h3>
        <span style="font-size: 13px; color: var(--text-secondary); margin-left: auto;">최종 크기: 980 × 530px</span>
      </div>
      <div class="modal-body" style="padding: 16px;">
        <!-- 미리보기 영역 -->
        <div class="content-resize-preview-container">
          <div class="content-resize-canvas-wrapper" id="contentResizeCanvasWrapper">
            <canvas id="contentResizeCanvas" width="490" height="265"></canvas>
            <img id="contentResizePreview" draggable="false" />
            <!-- 크롭 박스 -->
            <div class="crop-box" id="contentCropBox" style="display: none;">
              <div class="crop-box-handle nw" data-handle="nw"></div>
              <div class="crop-box-handle n" data-handle="n"></div>
              <div class="crop-box-handle ne" data-handle="ne"></div>
              <div class="crop-box-handle e" data-handle="e"></div>
              <div class="crop-box-handle se" data-handle="se"></div>
              <div class="crop-box-handle s" data-handle="s"></div>
              <div class="crop-box-handle sw" data-handle="sw"></div>
              <div class="crop-box-handle w" data-handle="w"></div>
            </div>
          </div>
        </div>

        <!-- 컨트롤 영역 -->
        <div class="content-resize-controls">
          <div class="resize-control-group">
            <label class="form-label" style="margin-bottom: 8px;">크롭 영역 조정</label>
            <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
              크롭 박스를 드래그하여 이동하고, 모서리나 가장자리의 핸들을 드래그하여 크기를 조정하세요. 비율은 자동으로 고정됩니다.
            </p>
            <div class="content-scale-info">
              <span id="contentCropInfo">크롭 영역: - × - px</span>
            </div>
          </div>
        </div>

        <!-- 썸네일 미리보기 -->
        <div class="thumbnail-preview-section">
          <h4>📷 자동 생성 썸네일 미리보기</h4>
          <div class="thumbnail-preview-grid">
            <div class="thumbnail-preview-item">
              <canvas id="thumbnailPreview320" width="160" height="90" style="width: 160px; height: 90px;"></canvas>
              <span>320 × 180px</span>
            </div>
            <div class="thumbnail-preview-item">
              <canvas id="thumbnailPreview640" width="160" height="90" style="width: 160px; height: 90px;"></canvas>
              <span>640 × 360px</span>
            </div>
          </div>
        </div>

        <p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; text-align: center;">
          💡 이미지를 드래그하여 위치를 조정하고, 확대/축소하여 원하는 영역을 선택할 수 있습니다. 최종적으로 1920×1080 크기로 잘라서 업로드됩니다.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelContentResizeBtn">취소</button>
        <button class="btn btn-primary" id="confirmContentResizeBtn">
          <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"
            style="margin-right: 4px;">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
          </svg>
          적용 및 업로드
        </button>
      </div>
    </div>
  </div>

  <!-- 토스트 컨테이너 -->
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // ===== 상태 관리 =====
    // UUID 생성 함수
    function generateUUID() {
      if (crypto.randomUUID) {
        return crypto.randomUUID();
      }
      // 폴백: 간단한 UUID v4 생성
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // ===== 이미지 리사이즈 모달 상태 =====
    const imageResizeState = {
      originalFile: null,
      originalImage: null,
      scale: 100,
      offsetX: 0,
      offsetY: 0,
      bgColor: '#FFFFFF',
      isDragging: false,
      dragStartX: 0,
      dragStartY: 0,
      resolveCallback: null,
      rejectCallback: null
    };

    // 이미지 리사이즈 모달 열기
    function openImageResizeModal(file) {
      return new Promise((resolve, reject) => {
        // SVG 파일은 모달 없이 바로 반환
        if (file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')) {
          resolve(file);
          return;
        }

        imageResizeState.originalFile = file;
        imageResizeState.resolveCallback = resolve;
        imageResizeState.rejectCallback = reject;

        // 이미지 로드
        const img = new Image();
        img.onload = () => {
          imageResizeState.originalImage = img;

          // 초기 스케일 계산 (캔버스에 맞추기)
          const fitScale = Math.min(800 / img.width, 600 / img.height) * 100;
          imageResizeState.scale = Math.round(fitScale);
          imageResizeState.bgColor = '#FFFFFF';

          // 중앙 배치
          const scaledWidth = img.width * (imageResizeState.scale / 100);
          const scaledHeight = img.height * (imageResizeState.scale / 100);
          imageResizeState.offsetX = (800 - scaledWidth) / 2;
          imageResizeState.offsetY = (600 - scaledHeight) / 2;

          // UI 업데이트
          document.getElementById('imageScaleSlider').value = imageResizeState.scale;
          updateImageResizePreview();
          updateScaleInfo();

          // 모달 표시
          document.getElementById('imageResizeModal').classList.add('show');
        };

        img.onerror = () => {
          reject(new Error('이미지를 불러올 수 없습니다.'));
        };

        const reader = new FileReader();
        reader.onload = (e) => {
          img.src = e.target.result;
        };
        reader.onerror = () => {
          reject(new Error('파일을 읽을 수 없습니다.'));
        };
        reader.readAsDataURL(file);
      });
    }

    // 미리보기 업데이트
    function updateImageResizePreview() {
      const preview = document.getElementById('imageResizePreview');
      const canvas = document.getElementById('imageResizeCanvas');
      const ctx = canvas.getContext('2d');
      const img = imageResizeState.originalImage;

      if (!img) return;

      const scaledWidth = img.width * (imageResizeState.scale / 100);
      const scaledHeight = img.height * (imageResizeState.scale / 100);

      // 캔버스에 최종 결과 그리기
      ctx.fillStyle = imageResizeState.bgColor;
      ctx.fillRect(0, 0, 800, 600);
      ctx.drawImage(img, imageResizeState.offsetX, imageResizeState.offsetY, scaledWidth, scaledHeight);
    }

    // 스케일 정보 업데이트
    function updateScaleInfo() {
      const img = imageResizeState.originalImage;
      if (!img) return;

      document.getElementById('scalePercentage').textContent = `${imageResizeState.scale}%`;
      const scaledWidth = Math.round(img.width * (imageResizeState.scale / 100));
      const scaledHeight = Math.round(img.height * (imageResizeState.scale / 100));
      document.getElementById('imageDimensions').textContent = `${scaledWidth} × ${scaledHeight} px (원본: ${img.width} × ${img.height})`;
    }

    // 캔버스에 맞추기
    function fitImageToCanvas() {
      const img = imageResizeState.originalImage;
      if (!img) return;

      const fitScale = Math.min(800 / img.width, 600 / img.height) * 100;
      imageResizeState.scale = Math.round(fitScale);

      const scaledWidth = img.width * (imageResizeState.scale / 100);
      const scaledHeight = img.height * (imageResizeState.scale / 100);
      imageResizeState.offsetX = (800 - scaledWidth) / 2;
      imageResizeState.offsetY = (600 - scaledHeight) / 2;

      document.getElementById('imageScaleSlider').value = imageResizeState.scale;
      updateImageResizePreview();
      updateScaleInfo();
    }

    // 최종 이미지 생성
    function generateResizedImage() {
      return new Promise((resolve, reject) => {
        const canvas = document.getElementById('imageResizeCanvas');

        canvas.toBlob((blob) => {
          if (blob) {
            const fileName = imageResizeState.originalFile.name.replace(/\.[^/.]+$/, '.png');
            const resizedFile = new File([blob], fileName, {
              type: 'image/png',
              lastModified: Date.now()
            });
            resolve(resizedFile);
          } else {
            reject(new Error('이미지 생성에 실패했습니다.'));
          }
        }, 'image/png', 0.95);
      });
    }

    // 이미지 리사이즈 함수 (호환성 유지)
    function resizeImage(file, maxWidth = 800, maxHeight = 600) {
      return openImageResizeModal(file);
    }

    // ===== 콘텐츠 이미지 리사이즈 모달 상태 (메인/홍보 화면용) =====
    const contentResizeState = {
      originalFile: null,
      originalImage: null,
      imageScale: 1, // 이미지 표시 스케일
      imageOffsetX: 0, // 이미지 오프셋 X
      imageOffsetY: 0, // 이미지 오프셋 Y
      cropBox: { x: 0, y: 0, width: 0, height: 0 }, // 크롭 박스 위치와 크기
      isDragging: false,
      isResizing: false,
      resizeHandle: null, // 리사이즈 핸들 ('nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w')
      dragStartX: 0,
      dragStartY: 0,
      dragStartCropBox: null, // 드래그 시작 시 크롭 박스 상태
      resolveCallback: null,
      rejectCallback: null,
      contentType: 'dashboard', // 'dashboard' 또는 'pr'
      canvasWidth: 490,  // 미리보기 캔버스 크기 (동적으로 설정됨)
      canvasHeight: 265, // 미리보기 캔버스 크기 (동적으로 설정됨)
      outputWidth: 980,  // 최종 출력 크기 (동적으로 설정됨)
      outputHeight: 530  // 최종 출력 크기 (동적으로 설정됨)
    };

    // 콘텐츠 이미지 리사이즈 모달 열기
    function openContentResizeModal(file, contentType = 'dashboard') {
      return new Promise((resolve, reject) => {
        contentResizeState.originalFile = file;
        contentResizeState.resolveCallback = resolve;
        contentResizeState.rejectCallback = reject;
        contentResizeState.contentType = contentType;

        // contentType에 따라 크기 설정
        if (contentType === 'dashboard') {
          // 메인 화면용: 980 × 530
          contentResizeState.outputWidth = 980;
          contentResizeState.outputHeight = 530;
          contentResizeState.canvasWidth = 490;  // 절반 크기
          contentResizeState.canvasHeight = 265; // 절반 크기
        } else {
          // 홍보 화면용: 976 × 1142
          contentResizeState.outputWidth = 976;
          contentResizeState.outputHeight = 1142;
          contentResizeState.canvasWidth = 488;  // 절반 크기
          contentResizeState.canvasHeight = 571; // 절반 크기
        }

        // 캔버스 및 wrapper 크기 업데이트
        const canvas = document.getElementById('contentResizeCanvas');
        const canvasWrapper = document.getElementById('contentResizeCanvasWrapper');
        canvas.width = contentResizeState.canvasWidth;
        canvas.height = contentResizeState.canvasHeight;
        // wrapper 크기도 비율에 맞게 업데이트
        canvasWrapper.style.width = `${contentResizeState.canvasWidth}px`;
        canvasWrapper.style.height = `${contentResizeState.canvasHeight}px`;

        // 모달 타이틀 및 최종 크기 업데이트
        const title = contentType === 'dashboard' ? '메인 화면 이미지 조정' : '홍보 화면 이미지 조정';
        document.getElementById('contentResizeModalTitle').textContent = title;
        const sizeText = `최종 크기: ${contentResizeState.outputWidth} × ${contentResizeState.outputHeight}px`;
        document.querySelector('#contentResizeModal .modal-header span').textContent = sizeText;

        // 이미지 로드
        const img = new Image();
        img.onload = () => {
          contentResizeState.originalImage = img;

          // 이미지 전체가 보이도록 스케일 계산 (fit to contain)
          const scaleX = contentResizeState.canvasWidth / img.width;
          const scaleY = contentResizeState.canvasHeight / img.height;
          contentResizeState.imageScale = Math.min(scaleX, scaleY);

          // 이미지 중앙 배치
          const scaledWidth = img.width * contentResizeState.imageScale;
          const scaledHeight = img.height * contentResizeState.imageScale;
          contentResizeState.imageOffsetX = (contentResizeState.canvasWidth - scaledWidth) / 2;
          contentResizeState.imageOffsetY = (contentResizeState.canvasHeight - scaledHeight) / 2;

          // 크롭 박스 초기화 (캔버스 전체 크기)
          contentResizeState.cropBox = {
            x: 0,
            y: 0,
            width: contentResizeState.canvasWidth,
            height: contentResizeState.canvasHeight
          };

          // UI 업데이트
          updateContentResizePreview();
          updateContentCropInfo();

          // 모달 표시
          document.getElementById('contentResizeModal').classList.add('show');
        };

        img.onerror = () => {
          reject(new Error('이미지를 불러올 수 없습니다.'));
        };

        const reader = new FileReader();
        reader.onload = (e) => {
          img.src = e.target.result;
        };
        reader.onerror = () => {
          reject(new Error('파일을 읽을 수 없습니다.'));
        };
        reader.readAsDataURL(file);
      });
    }

    // 콘텐츠 미리보기 업데이트
    function updateContentResizePreview() {
      const canvas = document.getElementById('contentResizeCanvas');
      const ctx = canvas.getContext('2d');
      const img = contentResizeState.originalImage;
      const cropBoxEl = document.getElementById('contentCropBox');

      if (!img) return;

      // 캔버스 초기화
      ctx.clearRect(0, 0, contentResizeState.canvasWidth, contentResizeState.canvasHeight);

      // 이미지 그리기 (전체 이미지)
      const scaledWidth = img.width * contentResizeState.imageScale;
      const scaledHeight = img.height * contentResizeState.imageScale;
      ctx.drawImage(
        img,
        contentResizeState.imageOffsetX,
        contentResizeState.imageOffsetY,
        scaledWidth,
        scaledHeight
      );

      // 크롭 박스 업데이트
      if (cropBoxEl) {
        cropBoxEl.style.display = 'block';
        cropBoxEl.style.left = `${contentResizeState.cropBox.x}px`;
        cropBoxEl.style.top = `${contentResizeState.cropBox.y}px`;
        cropBoxEl.style.width = `${contentResizeState.cropBox.width}px`;
        cropBoxEl.style.height = `${contentResizeState.cropBox.height}px`;
      }

      // 썸네일 미리보기 업데이트
      updateThumbnailPreviews();
    }

    // 크롭 정보 업데이트
    function updateContentCropInfo() {
      const cropBox = contentResizeState.cropBox;
      const infoElement = document.getElementById('contentCropInfo');
      if (infoElement) {
        const outputWidth = Math.round(cropBox.width * (contentResizeState.outputWidth / contentResizeState.canvasWidth));
        const outputHeight = Math.round(cropBox.height * (contentResizeState.outputHeight / contentResizeState.canvasHeight));
        infoElement.textContent = `크롭 영역: ${outputWidth} × ${outputHeight} px`;
      }
    }

    // 썸네일 미리보기 업데이트
    function updateThumbnailPreviews() {
      const canvas = document.getElementById('contentResizeCanvas');
      const cropBox = contentResizeState.cropBox;

      // 320x180 썸네일 미리보기
      const thumb320 = document.getElementById('thumbnailPreview320');
      const ctx320 = thumb320.getContext('2d');
      ctx320.clearRect(0, 0, 160, 90);
      ctx320.drawImage(
        canvas,
        cropBox.x, cropBox.y, cropBox.width, cropBox.height,
        0, 0, 160, 90
      );

      // 640x360 썸네일 미리보기
      const thumb640 = document.getElementById('thumbnailPreview640');
      const ctx640 = thumb640.getContext('2d');
      ctx640.clearRect(0, 0, 160, 90);
      ctx640.drawImage(
        canvas,
        cropBox.x, cropBox.y, cropBox.width, cropBox.height,
        0, 0, 160, 90
      );
    }


    // 최종 콘텐츠 이미지 생성 - 크롭 박스 기반
    function generateResizedContentImage() {
      return new Promise((resolve, reject) => {
        const img = contentResizeState.originalImage;
        if (!img) {
          reject(new Error('이미지가 없습니다.'));
          return;
        }

        // 크롭 박스 영역을 원본 이미지 좌표로 변환
        const cropBox = contentResizeState.cropBox;

        // 캔버스 좌표를 원본 이미지 좌표로 변환
        const canvasToImageX = (canvasX) => {
          return (canvasX - contentResizeState.imageOffsetX) / contentResizeState.imageScale;
        };
        const canvasToImageY = (canvasY) => {
          return (canvasY - contentResizeState.imageOffsetY) / contentResizeState.imageScale;
        };

        // 크롭 박스의 원본 이미지 상의 좌표 계산
        const sourceX = Math.max(0, canvasToImageX(cropBox.x));
        const sourceY = Math.max(0, canvasToImageY(cropBox.y));
        const sourceWidth = Math.min(
          img.width - sourceX,
          cropBox.width / contentResizeState.imageScale
        );
        const sourceHeight = Math.min(
          img.height - sourceY,
          cropBox.height / contentResizeState.imageScale
        );

        // 최종 출력용 캔버스 생성
        const outputCanvas = document.createElement('canvas');
        outputCanvas.width = contentResizeState.outputWidth;
        outputCanvas.height = contentResizeState.outputHeight;
        const ctx = outputCanvas.getContext('2d');

        // 원본 이미지에서 크롭 영역을 최종 출력 크기로 리사이즈하여 그리기
        ctx.drawImage(
          img,
          sourceX, sourceY, sourceWidth, sourceHeight,
          0, 0, contentResizeState.outputWidth, contentResizeState.outputHeight
        );

        outputCanvas.toBlob((blob) => {
          if (blob) {
            const sizeSuffix = `${contentResizeState.outputWidth}x${contentResizeState.outputHeight}`;
            const fileName = contentResizeState.originalFile.name.replace(/\.[^/.]+$/, `_${sizeSuffix}.png`);
            const resizedFile = new File([blob], fileName, {
              type: 'image/png',
              lastModified: Date.now()
            });
            resolve(resizedFile);
          } else {
            reject(new Error('이미지 생성에 실패했습니다.'));
          }
        }, 'image/png', 0.95);
      });
    }

    // 썸네일 이미지 생성 - 크롭 박스 기반
    function generateThumbnail(width, height) {
      return new Promise((resolve, reject) => {
        const img = contentResizeState.originalImage;
        if (!img) {
          reject(new Error('이미지가 없습니다.'));
          return;
        }

        // 크롭 박스 영역을 원본 이미지 좌표로 변환
        const cropBox = contentResizeState.cropBox;

        // 캔버스 좌표를 원본 이미지 좌표로 변환
        const canvasToImageX = (canvasX) => {
          return (canvasX - contentResizeState.imageOffsetX) / contentResizeState.imageScale;
        };
        const canvasToImageY = (canvasY) => {
          return (canvasY - contentResizeState.imageOffsetY) / contentResizeState.imageScale;
        };

        // 크롭 박스의 원본 이미지 상의 좌표 계산
        const sourceX = Math.max(0, canvasToImageX(cropBox.x));
        const sourceY = Math.max(0, canvasToImageY(cropBox.y));
        const sourceWidth = Math.min(
          img.width - sourceX,
          cropBox.width / contentResizeState.imageScale
        );
        const sourceHeight = Math.min(
          img.height - sourceY,
          cropBox.height / contentResizeState.imageScale
        );

        // 썸네일용 캔버스 생성
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = width;
        thumbCanvas.height = height;
        const ctx = thumbCanvas.getContext('2d');

        // 원본 이미지에서 크롭 영역을 썸네일 크기로 리사이즈하여 그리기
        ctx.drawImage(
          img,
          sourceX, sourceY, sourceWidth, sourceHeight,
          0, 0, width, height
        );

        thumbCanvas.toBlob((blob) => {
          if (blob) {
            const baseName = contentResizeState.originalFile.name.replace(/\.[^/.]+$/, '');
            const fileName = `${baseName}_${width}x${height}.png`;
            const thumbFile = new File([blob], fileName, {
              type: 'image/png',
              lastModified: Date.now()
            });
            resolve(thumbFile);
          } else {
            reject(new Error('썸네일 생성에 실패했습니다.'));
          }
        }, 'image/png', 0.9);
      });
    }

    // 모든 이미지(원본 + 썸네일) 생성
    async function generateAllContentImages() {
      const mainImage = await generateResizedContentImage();
      const thumb320 = await generateThumbnail(320, 180);
      const thumb640 = await generateThumbnail(640, 360);

      return {
        main: mainImage,
        thumbnails: {
          small: thumb320,
          medium: thumb640
        }
      };
    }

    const state = {
      isLoggedIn: false,
      user: null,
      currentPage: "dashboard",
      currentMode: "normal",
      slides: { slides: [], slides_low: [] },
      deleteTarget: null,
      buildings: [],
      currentBuilding: null,
      floorPlans: [],
      currentFloor: null,
      currentFloorData: null,
      selectedElement: null,
      draggedElement: null,
      dragOffset: { x: 0, y: 0 },
      addElementType: null,
      addElementIconType: null,
      resizedFloorImage: null, // 리사이즈된 층 이미지
    };

    // ===== API 함수 =====
    // const HOST = "http://192.168.0.18:8000";
    const HOST = "http://localhost:8000";
    const API_BASE = `${HOST}/api/v1`;

    // 테마 API
    async function apiGetThemes() {
      const res = await fetch(`${API_BASE}/config/themes`);
      return res.json();
    }

    async function apiSetTheme(themeId) {
      const res = await fetch(`${API_BASE}/config/themes/${themeId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" }
      });
      return res.json();
    }

    async function apiLogin(username, password) {
      const res = await fetch(`${API_BASE}/auth/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });
      return res.json();
    }

    async function apiGetSlides() {
      const res = await fetch(`${API_BASE}/slides/`);
      return res.json();
    }

    async function apiUploadSlide(file, mode) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("mode", mode);

      const res = await fetch(`${API_BASE}/slides/upload`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiDeleteSlide(slideId, mode) {
      const res = await fetch(`${API_BASE}/slides/${slideId}?mode=${mode}`, {
        method: "DELETE",
      });
      return res.json();
    }

    async function apiGetFloorInfo() {
      const res = await fetch(`${API_BASE}/floor-info`);
      return res.json();
    }

    async function apiGetDummyTable() {
      const res = await fetch(`${API_BASE}/dummy-table`);
      return res.json();
    }

    // 건물 API
    async function apiGetBuildings() {
      const res = await fetch(`${API_BASE}/buildings/`);
      return res.json();
    }

    async function apiCreateBuilding(data) {
      const res = await fetch(`${API_BASE}/buildings/`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      return res.json();
    }

    async function apiDeleteBuilding(buildingId) {
      const res = await fetch(`${API_BASE}/buildings/${buildingId}`, {
        method: "DELETE",
      });
      return res.json();
    }

    async function apiGetBuildingFloors(buildingId) {
      const res = await fetch(`${API_BASE}/buildings/${buildingId}/floors`);
      return res.json();
    }

    async function apiGetBuildingFloor(buildingId, floorNumber) {
      const res = await fetch(`${API_BASE}/buildings/${buildingId}/floors/${floorNumber}`);
      return res.json();
    }

    async function apiUploadBuildingFloorImage(buildingId, file, floorNumber) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("floor_number", floorNumber);
      const res = await fetch(`${API_BASE}/buildings/${buildingId}/floors/upload-image`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiSaveBuildingFloor(buildingId, floorNumber, data) {
      const res = await fetch(`${API_BASE}/buildings/${buildingId}/floors/${floorNumber}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      return res.json();
    }

    async function apiDeleteBuildingFloor(buildingId, floorNumber) {
      const res = await fetch(`${API_BASE}/buildings/${buildingId}/floors/${floorNumber}`, {
        method: "DELETE",
      });
      return res.json();
    }

    async function apiMigrateLegacyData() {
      const res = await fetch(`${API_BASE}/buildings/migrate-legacy`, {
        method: "POST",
      });
      return res.json();
    }

    // 하위 호환용 API (기존 floor-plan)
    async function apiGetFloorPlans() {
      const res = await fetch(`${API_BASE}/floor-plan/`);
      return res.json();
    }

    async function apiGetFloorPlan(floorNumber) {
      const res = await fetch(`${API_BASE}/floor-plan/${floorNumber}`);
      return res.json();
    }

    async function apiUploadFloorImage(file, floorNumber) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("floor_number", floorNumber);

      const res = await fetch(`${API_BASE}/floor-plan/upload-image`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiUploadFloorJson(file, floorNumber) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("floor_number", floorNumber);

      const res = await fetch(`${API_BASE}/floor-plan/upload-json`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiSaveFloorPlan(floorNumber, floorData) {
      const res = await fetch(`${API_BASE}/floor-plan/${floorNumber}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(floorData),
      });
      return res.json();
    }

    // 클라이언트 관리 API
    async function apiGetClients() {
      const res = await fetch(`${API_BASE}/clients`);
      return res.json();
    }

    async function apiGetClient(clientId) {
      const res = await fetch(`${API_BASE}/clients/${clientId}`);
      return res.json();
    }

    async function apiSetClientAlias(clientId, alias) {
      const res = await fetch(`${API_BASE}/clients/${clientId}/alias`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ alias }),
      });
      return res.json();
    }

    async function apiResetClientIndexedDB(clientId) {
      const res = await fetch(`${API_BASE}/clients/${clientId}/reset-indexeddb`, {
        method: "POST",
      });
      return res.json();
    }

    async function apiResetAllIndexedDB() {
      const res = await fetch(`${API_BASE}/clients/reset-all-indexeddb`, {
        method: "POST",
      });
      return res.json();
    }

    async function apiForceClientSync(clientId) {
      const res = await fetch(`${API_BASE}/clients/${clientId}/force-sync`, {
        method: "POST",
      });
      return res.json();
    }

    async function apiBroadcastSync() {
      const res = await fetch(`${API_BASE}/clients/broadcast-sync`, {
        method: "POST",
      });
      return res.json();
    }

    // 부서 관리 API
    async function apiGetDepartments() {
      const res = await fetch(`/content/departments/departments.json`);
      if (!res.ok) {
        throw new Error("부서 데이터를 불러올 수 없습니다.");
      }
      const data = await res.json();
      return { code: 200, data: data };
    }

    async function apiSendClientCommand(clientId, command, params = {}) {
      const res = await fetch(`${API_BASE}/clients/${clientId}/command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ command, params }),
      });
      return res.json();
    }

    async function apiGetSyncVersion() {
      const res = await fetch(`${API_BASE}/sync/version`);
      return res.json();
    }

    async function apiGetSyncStatus(clientId = null) {
      const url = clientId
        ? `${API_BASE}/sync/status?clientId=${clientId}`
        : `${API_BASE}/sync/status`;
      const res = await fetch(url);
      return res.json();
    }

    // 대시보드 이미지 API
    async function apiGetDashboardImages() {
      const res = await fetch(`${API_BASE}/media/dashboard`);
      return res.json();
    }

    async function apiUploadDashboardImage(file, order = 0) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("order", order);
      const res = await fetch(`${API_BASE}/media/dashboard/upload`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiDeleteDashboardImage(imageId) {
      const res = await fetch(`${API_BASE}/media/dashboard/${imageId}`, {
        method: "DELETE",
      });
      return res.json();
    }

    async function apiUpdateDashboardImageOrder(imageId, order) {
      const res = await fetch(`${API_BASE}/media/dashboard/${imageId}/order`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ order }),
      });
      return res.json();
    }

    async function apiUpdateDashboardImageName(imageId, name) {
      const res = await fetch(`${API_BASE}/media/dashboard/${imageId}/name`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      return res.json();
    }

    // 홍보 이미지 API
    async function apiGetPrImages() {
      const res = await fetch(`${API_BASE}/media/pr`);
      return res.json();
    }

    async function apiUploadPrImage(file, order = 0) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("order", order);
      const res = await fetch(`${API_BASE}/media/pr/upload`, {
        method: "POST",
        body: formData,
      });
      return res.json();
    }

    async function apiDeletePrImage(imageId) {
      const res = await fetch(`${API_BASE}/media/pr/${imageId}`, {
        method: "DELETE",
      });
      return res.json();
    }

    async function apiUpdatePrImageOrder(imageId, order) {
      const res = await fetch(`${API_BASE}/media/pr/${imageId}/order`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ order }),
      });
      return res.json();
    }

    async function apiUpdatePrImageName(imageId, name) {
      const res = await fetch(`${API_BASE}/media/pr/${imageId}/name`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });
      return res.json();
    }

    // ===== 유틸리티 함수 =====

    // CSS 변수 값 가져오기
    function getCssVar(varName) {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    // 테마 색상 상수 (CSS 변수 참조)
    const THEME = {
      get textDefault() { return getCssVar('--text-default') || '#333333'; },
      get textDark() { return getCssVar('--text-dark') || '#000000'; },
      get currentLocation() { return getCssVar('--current-location') || '#FFEB3B'; },
      get currentLocationDark() { return getCssVar('--current-location-dark') || '#FDD835'; },
    };

    function showToast(message, type = "success") {
      const container = document.getElementById("toastContainer");
      const toast = document.createElement("div");
      toast.className = `toast ${type}`;
      toast.innerHTML = message;
      container.appendChild(toast);

      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    function formatDate(dateStr) {
      const date = new Date(dateStr);
      return date.toLocaleDateString("ko-KR", {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });
    }

    // ===== UI 함수 =====
    function showLogin() {
      document.getElementById("loginPage").style.display = "flex";
      document.getElementById("dashboard").classList.remove("show");
    }

    function showDashboard() {
      document.getElementById("loginPage").style.display = "none";
      document.getElementById("dashboard").classList.add("show");
      loadDashboardData();
      loadThemes(); // 테마 로드
    }

    function showPage(pageName, skipAutoLoad = false) {
      // console.log("showPage", pageName);
      state.currentPage = pageName;

      // 모든 페이지 숨기기
      document.querySelectorAll(".dashboard-page, .slides-page").forEach((p) => {
        p.style.display = "none";
      });

      // 네비게이션 업데이트
      document.querySelectorAll(".nav-item").forEach((item) => {
        item.classList.remove("active");
        if (item.dataset.page === pageName) {
          item.classList.add("active");
        }
      });

      // 해당 페이지 표시
      if (pageName === "dashboard") {
        document.getElementById("dashboardPage").style.display = "block";
      } else if (pageName === "slides") {
        document.getElementById("slidesPage").style.display = "block";
        if (!skipAutoLoad) loadContentImages();
      } else if (pageName === "buildings") {
        document.getElementById("buildingsPage").style.display = "block";
        if (!skipAutoLoad) loadBuildings();
      } else if (pageName === "floor-plan") {
        document.getElementById("floorPlanPage").style.display = "block";
        if (!skipAutoLoad) loadBuildingsForFloorPlan();
      } else if (pageName === "clients") {
        document.getElementById("clientsPage").style.display = "block";
        if (!skipAutoLoad) loadClients();
      } else if (pageName === "settings") {
        document.getElementById("settingsPage").style.display = "block";
        renderThemeGrid(); // 테마 그리드 렌더링
      } else if (pageName === "departments") {
        document.getElementById("departmentsPage").style.display = "block";
        if (!skipAutoLoad) loadDepartments();
      }
    }

    // ===== 클라이언트 관리 함수 =====
    let clientRefreshInterval = null;

    async function loadClients() {
      try {
        // 동기화 버전 정보 로드
        const versionRes = await apiGetSyncVersion();
        if (versionRes.code === 200) {
          document.getElementById("dataVersion").textContent = versionRes.data.version;
          document.getElementById("lastUpdateTime").textContent = formatDateTime(versionRes.data.lastUpdate);
        }

        // 클라이언트 목록 로드
        const clientsRes = await apiGetClients();
        if (clientsRes.code === 200) {
          renderClients(clientsRes.data.clients);
          document.getElementById("connectedClientCount").textContent = clientsRes.data.totalCount;
          document.getElementById("clientCountBadge").textContent = clientsRes.data.totalCount;
        }

        // 자동 갱신 시작 (5초마다)
        if (!clientRefreshInterval) {
          clientRefreshInterval = setInterval(async () => {
            if (state.currentPage === "clients") {
              await refreshClientListSilent();
            }
          }, 5000);
        }
      } catch (error) {
        console.error("클라이언트 목록 로드 실패:", error);
        showToast("클라이언트 목록을 불러올 수 없습니다.", "error");
      }
    }

    async function refreshClientListSilent() {
      try {
        const versionRes = await apiGetSyncVersion();
        if (versionRes.code === 200) {
          document.getElementById("dataVersion").textContent = versionRes.data.version;
          document.getElementById("lastUpdateTime").textContent = formatDateTime(versionRes.data.lastUpdate);
        }

        const clientsRes = await apiGetClients();
        if (clientsRes.code === 200) {
          renderClients(clientsRes.data.clients);
          document.getElementById("connectedClientCount").textContent = clientsRes.data.totalCount;
          document.getElementById("clientCountBadge").textContent = clientsRes.data.totalCount;
        }
      } catch (error) {
        console.error("클라이언트 목록 갱신 실패:", error);
      }
    }

    async function refreshClientList() {
      showToast("클라이언트 목록을 갱신합니다.");
      await loadClients();
    }

    function renderClients(clients) {
      const container = document.getElementById("clientList");

      if (!clients || clients.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
              </svg>
              <h3 class="empty-title">연결된 클라이언트가 없습니다</h3>
              <p class="empty-description">Viewo 클라이언트 앱이 실행되면 여기에 표시됩니다.</p>
            </div>
          `;
        return;
      }

      let html = "";
      for (const client of clients) {
        const shortId = client.clientId.slice(0, 8) + "...";
        const aliasValue = client.alias || "";
        const connectedTime = formatDateTime(client.connectedAt);
        const lastHeartbeat = formatDateTime(client.lastHeartbeat);

        html += `
            <div class="client-card" data-client-id="${client.clientId}">
              <div class="client-header">
                <div class="client-status">
                  <span class="status-dot online"></span>
                  <span class="status-text">온라인</span>
                </div>
                <div class="client-id-badge" title="${client.clientId}">${shortId}</div>
              </div>
              
              <div class="client-body">
                <div class="client-alias-row">
                  <input type="text" class="form-input alias-input" 
                         placeholder="별칭 입력..." 
                         value="${aliasValue}"
                         data-client-id="${client.clientId}" />
                  <button class="btn btn-primary btn-sm" onclick="saveClientAlias('${client.clientId}')">저장</button>
                </div>
                
                <div class="client-info">
                  <div class="info-row">
                    <span class="info-label">연결 시간:</span>
                    <span class="info-value">${connectedTime}</span>
                  </div>
                  <div class="info-row">
                    <span class="info-label">마지막 응답:</span>
                    <span class="info-value">${lastHeartbeat}</span>
                  </div>
                  <div class="info-row">
                    <span class="info-label">IP 주소:</span>
                    <span class="info-value">${client.ipAddress || "-"}</span>
                  </div>
                  <div class="info-row">
                    <span class="info-label">User Agent:</span>
                    <span class="info-value" title="${client.userAgent || '-'}">${truncateText(client.userAgent || "-", 30)}</span>
                  </div>
                </div>
              </div>
              
              <div class="client-actions">
                <button class="btn btn-secondary btn-sm" onclick="forceClientSync('${client.clientId}')">
                  <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right: 4px;">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                  </svg>
                  동기화
                </button>
                <button class="btn btn-warning btn-sm" onclick="resetClientDB('${client.clientId}')">
                  <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right: 4px;">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
                  DB 초기화
                </button>
                <button class="btn btn-danger btn-sm" onclick="reloadClient('${client.clientId}')">
                  <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right: 4px;">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  새로고침
                </button>
              </div>
            </div>
          `;
      }
      container.innerHTML = html;
    }

    async function saveClientAlias(clientId) {
      const input = document.querySelector(`.alias-input[data-client-id="${clientId}"]`);
      const alias = input.value.trim();

      try {
        const res = await apiSetClientAlias(clientId, alias);
        if (res.code === 200) {
          showToast("별칭이 저장되었습니다.");
        } else {
          showToast(res.message || "별칭 저장에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("별칭 저장에 실패했습니다.", "error");
      }
    }

    async function resetClientDB(clientId) {
      if (!confirm("이 클라이언트의 로컬 데이터를 초기화하시겠습니까?")) return;

      try {
        const res = await apiResetClientIndexedDB(clientId);
        if (res.code === 200) {
          showToast("초기화 명령이 전송되었습니다.");
        } else {
          showToast(res.message || "초기화 명령 전송에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("초기화 명령 전송에 실패했습니다.", "error");
      }
    }

    async function resetAllIndexedDB() {
      const clientCount = document.getElementById("connectedClientCount").textContent;
      if (!confirm(`연결된 모든 클라이언트(${clientCount}대)의 로컬 데이터를 초기화하시겠습니까?`)) return;

      try {
        const res = await apiResetAllIndexedDB();
        if (res.code === 200) {
          showToast("전체 초기화 명령이 전송되었습니다.");
        } else {
          showToast(res.message || "전체 초기화 명령 전송에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("전체 초기화 명령 전송에 실패했습니다.", "error");
      }
    }

    async function forceClientSync(clientId) {
      try {
        const res = await apiForceClientSync(clientId);
        if (res.code === 200) {
          showToast("동기화 명령이 전송되었습니다.");
        } else {
          showToast(res.message || "동기화 명령 전송에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("동기화 명령 전송에 실패했습니다.", "error");
      }
    }

    async function syncAllClients() {
      try {
        const res = await apiBroadcastSync();
        if (res.code === 200) {
          showToast("전체 동기화 명령이 전송되었습니다.");
        } else {
          showToast(res.message || "전체 동기화 명령 전송에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("전체 동기화 명령 전송에 실패했습니다.", "error");
      }
    }

    async function reloadClient(clientId) {
      if (!confirm("이 클라이언트를 새로고침 하시겠습니까?")) return;

      try {
        const res = await apiSendClientCommand(clientId, "reload");
        if (res.code === 200) {
          showToast("새로고침 명령이 전송되었습니다.");
        } else {
          showToast(res.message || "명령 전송에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("명령 전송에 실패했습니다.", "error");
      }
    }

    // ===== 부서 관리 함수 =====
    let departmentsData = [];
    let filteredDepartments = [];
    let DEPARTMENTS_PER_PAGE = 50;
    let currentPage = 1;

    async function loadDepartments() {
      try {
        const res = await apiGetDepartments();
        if (res.code === 200) {
          departmentsData = res.data;
          filteredDepartments = [...departmentsData];
          currentPage = 1;
          // 페이지당 항목 수 선택 드롭다운 초기화
          const select = document.getElementById("itemsPerPageSelect");
          if (select) {
            select.value = DEPARTMENTS_PER_PAGE.toString();
          }
          renderDepartments();
          showToast("부서 데이터를 불러왔습니다.");
        } else {
          showToast("부서 데이터를 불러올 수 없습니다.", "error");
        }
      } catch (error) {
        console.error("부서 데이터 로드 실패:", error);
        showToast("부서 데이터를 불러올 수 없습니다.", "error");
        document.getElementById("departmentsTableBody").innerHTML = `
            <tr>
              <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                데이터를 불러올 수 없습니다.
              </td>
            </tr>
          `;
      }
    }

    function changeItemsPerPage() {
      const select = document.getElementById("itemsPerPageSelect");
      const newValue = parseInt(select.value);
      DEPARTMENTS_PER_PAGE = newValue;
      currentPage = 1;
      renderDepartments();
    }

    function filterDepartments() {
      const searchTerm = document.getElementById("departmentSearchInput").value.toLowerCase();
      if (!searchTerm) {
        filteredDepartments = [...departmentsData];
      } else {
        filteredDepartments = departmentsData.filter(dept => {
          return (
            (dept.building && dept.building.toLowerCase().includes(searchTerm)) ||
            (dept.floor && dept.floor.toLowerCase().includes(searchTerm)) ||
            (dept.department && dept.department.toLowerCase().includes(searchTerm)) ||
            (dept.team && dept.team && dept.team.toLowerCase().includes(searchTerm)) ||
            (dept.position && dept.position.toLowerCase().includes(searchTerm)) ||
            (dept.task && dept.task.toLowerCase().includes(searchTerm))
          );
        });
      }
      currentPage = 1;
      renderDepartments();
    }

    function renderDepartments() {
      const tbody = document.getElementById("departmentsTableBody");
      const totalPages = Math.ceil(filteredDepartments.length / DEPARTMENTS_PER_PAGE);
      const startIndex = (currentPage - 1) * DEPARTMENTS_PER_PAGE;
      const endIndex = startIndex + DEPARTMENTS_PER_PAGE;
      const pageData = filteredDepartments.slice(startIndex, endIndex);

      if (pageData.length === 0) {
        tbody.innerHTML = `
            <tr>
              <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                검색 결과가 없습니다.
              </td>
            </tr>
          `;
        document.getElementById("departmentsPagination").style.display = "none";
        return;
      }

      let html = "";
      for (const dept of pageData) {
        html += `
            <tr>
              <td>${dept.building || "-"}</td>
              <td>${dept.floor || "-"}</td>
              <td>${dept.department || "-"}</td>
              <td>${dept.team || "-"}</td>
              <td>${dept.position || "-"}</td>
              <td style="max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${dept.task || "-"}">${dept.task || "-"}</td>
            </tr>
          `;
      }
      tbody.innerHTML = html;

      // 페이지네이션 렌더링
      if (totalPages > 1) {
        renderPagination(totalPages);
        document.getElementById("departmentsPagination").style.display = "flex";
      } else {
        document.getElementById("departmentsPagination").style.display = "none";
      }
    }

    function renderPagination(totalPages) {
      const pagination = document.getElementById("departmentsPagination");
      let html = `<div style="display: flex; gap: 8px; align-items: center; justify-content: center;">`;

      // 맨 처음 페이지 버튼
      html += `<button style="background: none; border: none; color: var(--text-primary); cursor: ${currentPage === 1 ? "not-allowed" : "pointer"}; opacity: ${currentPage === 1 ? "0.5" : "1"}; padding: 8px 12px; font-size: 14px;" ${currentPage === 1 ? "disabled" : ""} onclick="goToPage(1)">&lt;&lt;</button>`;

      // 이전 페이지 버튼
      html += `<button style="background: none; border: none; color: var(--text-primary); cursor: ${currentPage === 1 ? "not-allowed" : "pointer"}; opacity: ${currentPage === 1 ? "0.5" : "1"}; padding: 8px 12px; font-size: 14px;" ${currentPage === 1 ? "disabled" : ""} onclick="goToPage(${currentPage - 1})">&lt;</button>`;

      // 현재 페이지 표시
      html += `<span style="padding: 8px 12px; color: var(--text-primary); font-size: 14px;">${currentPage} / ${totalPages}</span>`;

      // 다음 페이지 버튼
      html += `<button style="background: none; border: none; color: var(--text-primary); cursor: ${currentPage === totalPages ? "not-allowed" : "pointer"}; opacity: ${currentPage === totalPages ? "0.5" : "1"}; padding: 8px 12px; font-size: 14px;" ${currentPage === totalPages ? "disabled" : ""} onclick="goToPage(${currentPage + 1})">&gt;</button>`;

      // 맨 끝 페이지 버튼
      html += `<button style="background: none; border: none; color: var(--text-primary); cursor: ${currentPage === totalPages ? "not-allowed" : "pointer"}; opacity: ${currentPage === totalPages ? "0.5" : "1"}; padding: 8px 12px; font-size: 14px;" ${currentPage === totalPages ? "disabled" : ""} onclick="goToPage(${totalPages})">&gt;&gt;</button>`;

      html += `<span style="margin-left: 16px; color: var(--text-secondary);">총 ${filteredDepartments.length}개 중 ${(currentPage - 1) * DEPARTMENTS_PER_PAGE + 1}-${Math.min(currentPage * DEPARTMENTS_PER_PAGE, filteredDepartments.length)}개 표시</span>`;
      html += `</div>`;

      pagination.innerHTML = html;
    }

    function goToPage(page) {
      const totalPages = Math.ceil(filteredDepartments.length / DEPARTMENTS_PER_PAGE);
      if (page < 1 || page > totalPages) return;
      currentPage = page;
      renderDepartments();
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function formatDateTime(isoString) {
      if (!isoString) return "-";
      try {
        const date = new Date(isoString);
        return date.toLocaleString("ko-KR", {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      } catch (e) {
        return isoString;
      }
    }

    function truncateText(text, maxLength) {
      if (!text || text.length <= maxLength) return text;
      return text.slice(0, maxLength) + "...";
    }

    async function loadDashboardData() {
      try {
        // 슬라이드 수
        const slidesRes = await apiGetSlides();
        if (slidesRes.code === 200) {
          const total = (slidesRes.data.slides?.length || 0) + (slidesRes.data.slides_low?.length || 0);
          document.getElementById("slideCount").textContent = total;
        }

        // 건물/층 정보
        const buildingsRes = await apiGetBuildings();
        if (buildingsRes.code === 200) {
          let totalFloors = 0;
          for (const building of buildingsRes.data) {
            const floorsRes = await apiGetBuildingFloors(building.id);
            if (floorsRes.code === 200) {
              totalFloors += floorsRes.data.length;
            }
          }
          document.getElementById("floorCount").textContent =
            `${buildingsRes.data.length}건물 / ${totalFloors}층`;
        }

        // 부서 정보
        const deptRes = await apiGetDummyTable();
        if (deptRes.code === 200) {
          document.getElementById("deptCount").textContent =
            deptRes.data.length || 0;
        }
      } catch (error) {
        console.error("대시보드 데이터 로드 실패:", error);
      }
    }

    // ===== 건물 관리 함수 =====
    async function loadBuildings() {
      const grid = document.getElementById("buildingsGrid");
      grid.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

      try {
        const res = await apiGetBuildings();
        if (res.code === 200) {
          state.buildings = res.data;
          renderBuildings();
        }
      } catch (error) {
        grid.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
              </svg>
              <h3 class="empty-title">건물 목록을 불러올 수 없습니다</h3>
              <p class="empty-description">잠시 후 다시 시도해주세요.</p>
            </div>
          `;
      }
    }

    async function renderBuildings() {
      const grid = document.getElementById("buildingsGrid");

      if (state.buildings.length === 0) {
        grid.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
              </svg>
              <h3 class="empty-title">등록된 건물이 없습니다</h3>
              <p class="empty-description">위에서 새 건물을 생성하거나 기존 데이터를 가져오세요.</p>
            </div>
          `;
        return;
      }

      let html = '';
      for (const building of state.buildings) {
        let floorCount = 0;
        try {
          const floorsRes = await apiGetBuildingFloors(building.id);
          if (floorsRes.code === 200) {
            floorCount = floorsRes.data.length;
          }
        } catch (e) { }

        html += `
            <div class="image-card">
              <div style="height: 120px; background: linear-gradient(135deg, var(--primary-light) 0%, var(--gray-100) 100%); display: flex; align-items: center; justify-content: center;">
                <svg width="48" height="48" fill="none" stroke="var(--primary)" stroke-width="1.5" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                </svg>
              </div>
              <div class="image-info">
                <div class="image-name">${building.name}</div>
                <div class="image-meta">${floorCount}개 층</div>
                <div class="image-actions">
                  <button class="btn btn-primary btn-sm" onclick="editBuilding('${building.id}')">
                    편집
                  </button>
                  <button class="btn btn-danger btn-sm" onclick="confirmDeleteBuilding('${building.id}', '${building.name}')">
                    삭제
                  </button>
                </div>
              </div>
            </div>
          `;
      }
      grid.innerHTML = html;
    }

    async function createBuilding() {
      const name = document.getElementById("newBuildingName").value.trim();

      if (!name) {
        showToast("건물 이름을 입력하세요.", "error");
        return;
      }

      try {
        const res = await apiCreateBuilding({ name });
        if (res.code === 200) {
          showToast("건물이 생성되었습니다.");
          document.getElementById("newBuildingName").value = "";
          loadBuildings();
        } else {
          showToast(res.detail || "건물 생성에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("건물 생성에 실패했습니다.", "error");
      }
    }

    function editBuilding(buildingId) {
      showPage("floor-plan");
      setTimeout(() => {
        document.getElementById("buildingSelect").value = buildingId;
        onBuildingSelect();
      }, 100);
    }

    function confirmDeleteBuilding(buildingId, buildingName) {
      state.deleteTarget = { type: 'building', buildingId, buildingName };
      document.querySelector("#deleteModal .modal-title").textContent = "건물 삭제";
      document.querySelector("#deleteModal .modal-body p").textContent =
        `"${buildingName}" 건물을 삭제하시겠습니까? 해당 건물의 모든 층 데이터도 함께 삭제됩니다.`;
      document.getElementById("deleteModal").classList.add("show");
    }

    async function deleteBuilding() {
      if (!state.deleteTarget || state.deleteTarget.type !== 'building') return;

      try {
        const res = await apiDeleteBuilding(state.deleteTarget.buildingId);
        if (res.code === 200) {
          showToast("건물이 삭제되었습니다.");
          loadBuildings();
        } else {
          showToast(res.detail || "삭제에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("삭제에 실패했습니다.", "error");
      }

      document.getElementById("deleteModal").classList.remove("show");
      state.deleteTarget = null;
    }

    async function migrateLegacyData() {
      if (!confirm("기존 floors 폴더의 데이터를 새 건물 구조로 가져오시겠습니까?\n기존 데이터는 '본관' 건물로 생성됩니다.")) {
        return;
      }

      try {
        const res = await apiMigrateLegacyData();
        if (res.code === 200) {
          if (res.data && res.data.floors && res.data.floors.length > 0) {
            showToast(`마이그레이션 완료: ${res.data.floors.length}개 층이 가져와졌습니다.`);
            loadBuildings();
          } else {
            showToast("마이그레이션할 데이터가 없습니다.");
          }
        } else {
          showToast(res.detail || "마이그레이션에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("마이그레이션에 실패했습니다.", "error");
      }
    }

    // ===== 청사도 관리 함수 =====

    // 층 번호를 표시 문자열로 변환하는 헬퍼 함수
    function formatFloorName(floorNumber) {
      if (floorNumber < 0) {
        return `지하 ${Math.abs(floorNumber)}층`;
      }
      return `${floorNumber}층`;
    }

    // 층 번호 선택기 상태
    let currentFloorNumberValue = 1;

    // 층 번호 표시 업데이트
    function updateFloorNumberDisplay() {
      const display = document.getElementById("floorNumberDisplay");
      const input = document.getElementById("newFloorNumber");

      display.textContent = formatFloorName(currentFloorNumberValue);
      input.value = currentFloorNumberValue;
    }

    // 층 번호 증가
    function incrementFloorNumber() {
      if (currentFloorNumberValue === -1) {
        currentFloorNumberValue = 1; // -1에서 0 건너뛰고 1로
      } else if (currentFloorNumberValue < 99) {
        currentFloorNumberValue++;
      }
      updateFloorNumberDisplay();
    }

    // 층 번호 감소
    function decrementFloorNumber() {
      if (currentFloorNumberValue === 1) {
        currentFloorNumberValue = -1; // 1에서 0 건너뛰고 -1로
      } else if (currentFloorNumberValue > -99) {
        currentFloorNumberValue--;
      }
      updateFloorNumberDisplay();
    }

    // 층 번호 리셋
    function resetFloorNumber() {
      currentFloorNumberValue = 1;
      updateFloorNumberDisplay();
    }

    async function loadBuildingsForFloorPlan() {
      const select = document.getElementById("buildingSelect");
      select.innerHTML = '<option value="">건물을 선택하세요</option>';

      try {
        const res = await apiGetBuildings();
        if (res.code === 200) {
          state.buildings = res.data;
          for (const building of state.buildings) {
            const option = document.createElement("option");
            option.value = building.id;
            option.textContent = building.name;
            select.appendChild(option);
          }
          // 첫 번째 건물이 있다면 자동 선택
          if (state.buildings.length > 0) {
            select.value = state.buildings[0].id;
            onBuildingSelect();
          }
        }
      } catch (error) {
        showToast("건물 목록을 불러오는데 실패했습니다.", "error");
      }
    }

    async function onBuildingSelect() {
      const buildingId = document.getElementById("buildingSelect").value;
      const floorSelect = document.getElementById("floorSelect");
      const floorManagementSection = document.getElementById("floorManagementSection");
      const jsonImportSection = document.getElementById("jsonImportSection");
      const editorSection = document.getElementById("editorSection");
      const editorPlaceholder = document.getElementById("editorPlaceholder");

      state.currentBuilding = buildingId;
      state.currentFloor = null;
      state.currentFloorData = null;
      floorSelect.innerHTML = '<option value="">층을 선택하세요</option>';

      if (!buildingId) {
        floorSelect.disabled = true;
        floorManagementSection.style.display = "none";
        jsonImportSection.style.display = "none";
        editorSection.style.display = "none";
        editorPlaceholder.style.display = "block";
        return;
      }

      floorSelect.disabled = false;
      floorManagementSection.style.display = "block";
      jsonImportSection.style.display = "block";

      try {
        const res = await apiGetBuildingFloors(buildingId);
        if (res.code === 200) {
          state.floorPlans = res.data;
          for (const floor of res.data) {
            const option = document.createElement("option");
            option.value = floor.floor;
            option.textContent = formatFloorName(floor.floor);
            floorSelect.appendChild(option);
          }
          renderFloorList();
        }
      } catch (error) {
        showToast("층 목록을 불러오는데 실패했습니다.", "error");
      }
    }

    function renderFloorList() {
      const floorList = document.getElementById("floorList");
      if (!floorList) return;

      if (state.floorPlans.length === 0) {
        floorList.innerHTML = `
            <div style="text-align: center; padding: 20px; color: var(--gray-500); font-size: 13px;">
              등록된 층이 없습니다
            </div>
          `;
        return;
      }

      // 내림차순 정렬 (높은 층 -> 낮은 층)
      const sortedFloors = [...state.floorPlans].sort((a, b) => b.floor - a.floor);

      floorList.innerHTML = sortedFloors.map(floor => `
          <div class="floor-list-item ${state.currentFloor === floor.floor ? 'selected' : ''}" 
               data-floor="${floor.floor}"
               onclick="selectFloorFromList(${floor.floor})">
            <span class="floor-name">${formatFloorName(floor.floor)}</span>
            <div class="floor-actions">
              <button class="btn-icon btn-icon-danger" onclick="event.stopPropagation(); confirmDeleteFloor(${floor.floor})" title="삭제">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
                </svg>
              </button>
            </div>
          </div>
        `).join('');
    }

    async function selectFloorFromList(floorNumber) {
      state.currentFloor = floorNumber;
      document.getElementById("floorSelect").value = floorNumber;
      renderFloorList();
      await loadFloorData(floorNumber);
    }

    async function loadFloorData(floorNumber) {
      if (!state.currentBuilding) {
        showToast("건물을 먼저 선택하세요.", "error");
        return;
      }

      state.currentFloor = floorNumber;

      try {
        const res = await apiGetBuildingFloor(state.currentBuilding, floorNumber);
        if (res.code === 200 && res.data) {
          state.currentFloorData = res.data;
          // buildingId 필드 보장
          if (!state.currentFloorData.buildingId) {
            state.currentFloorData.buildingId = state.currentBuilding;
          }
          window.loadFloorPlanEditor();
          showToast(`${formatFloorName(floorNumber)} 데이터를 불러왔습니다.`);
        } else {
          // 데이터가 없으면 빈 데이터 생성
          createEmptyFloorData(floorNumber);
        }
      } catch (error) {
        // 데이터가 없으면 빈 데이터 생성
        createEmptyFloorData(floorNumber);
      }
    }

    function createEmptyFloorData(floorNumber) {
      // 층 정보에서 이미지 경로 찾기
      const floorInfo = state.floorPlans.find(f => f.floor === floorNumber);
      const floorImage = floorInfo?.floorImage || "";

      state.currentFloorData = {
        floor: floorNumber,
        floorName: formatFloorName(floorNumber),
        buildingId: state.currentBuilding, // 필수 필드 추가
        floorImage: floorImage,
        imageSize: {
          width: 800,
          height: 600
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        iconTypes: {
          toiletMan: {
            icon: "images/icons/toilet_man.svg",
            label: "남자화장실"
          },
          toiletWoman: {
            icon: "images/icons/toilet_woman.svg",
            label: "여자화장실"
          },
          restaurant: {
            icon: "images/icons/dish-02.svg",
            label: "식당"
          },
          printer: {
            icon: "images/icons/printer.svg",
            label: "복사기"
          }
        },
        elements: [],
        currentLocation: {
          enabled: false,
          x1: 400,
          y1: 300,
          x2: 455,
          y2: 362,
          icon: "images/icons/current_location.svg",
          showLabel: true,
          labelText: "현위치",
          labelStyle: {
            fontSize: 11,
            fontFamily: "Pretendard",
            fontWeight: "bold",
            color: THEME.textDark,
            backgroundColor: THEME.currentLocation,
            borderRadius: 12
          }
        }
      };

      window.loadFloorPlanEditor();
      showToast(`${formatFloorName(floorNumber)} 새 편집을 시작합니다. 저장 버튼을 눌러 저장하세요.`);
    }

    function onFloorSelect() {
      const floorNumber = document.getElementById("floorSelect").value;
      state.currentFloor = floorNumber ? parseInt(floorNumber) : null;
      renderFloorList();
    }

    // 내보내기 드롭다운 토글
    function toggleExportDropdown() {
      const dropdown = document.getElementById("exportDropdown");
      dropdown.classList.toggle("open");
    }

    // 드롭다운 외부 클릭 시 닫기
    document.addEventListener("click", (e) => {
      const dropdown = document.getElementById("exportDropdown");
      if (dropdown && !dropdown.contains(e.target)) {
        dropdown.classList.remove("open");
      }
    });

    // 툴바 층 정보 업데이트
    function updateToolbarFloorInfo() {
      const toolbarFloorInfo = document.getElementById("toolbarFloorInfo");
      if (toolbarFloorInfo && state.currentBuilding && state.currentFloor !== null) {
        const buildingName = state.buildings.find(b => b.id === state.currentBuilding)?.name || state.currentBuilding;
        toolbarFloorInfo.textContent = `${buildingName} ${formatFloorName(state.currentFloor)}`;
      }
    }

    function toggleAddFloorUI() {
      const addFloorUI = document.getElementById("addFloorUI");
      const toggleBtn = document.getElementById("addFloorToggleBtn");

      if (addFloorUI.style.display === "none") {
        addFloorUI.style.display = "block";
        toggleBtn.style.display = "none";
      } else {
        addFloorUI.style.display = "none";
        toggleBtn.style.display = "flex";
      }
    }

    async function addFloor() {
      if (!state.currentBuilding) {
        showToast("건물을 먼저 선택하세요.", "error");
        return;
      }

      const floorNumber = parseInt(document.getElementById("newFloorNumber").value);
      const fileInput = document.getElementById("newFloorImage");

      if (isNaN(floorNumber) || floorNumber === 0) {
        showToast("유효한 층 번호를 입력하세요. (0층은 사용할 수 없습니다)", "error");
        return;
      }

      // 중복 층 확인
      const existingFloor = state.floorPlans.find(f => f.floor === floorNumber);
      if (existingFloor) {
        showToast(`${formatFloorName(floorNumber)}은(는) 이미 존재합니다.`, "error");
        return;
      }

      if (!state.resizedFloorImage) {
        showToast("청사도 이미지를 선택하세요.", "error");
        return;
      }

      try {
        const res = await apiUploadBuildingFloorImage(state.currentBuilding, state.resizedFloorImage, floorNumber);
        if (res.code === 200) {
          showToast(`${formatFloorName(floorNumber)}이 추가되었습니다.`);
          resetFloorNumber();
          fileInput.value = "";
          state.resizedFloorImage = null; // 리사이즈된 이미지 초기화
          // 파일명 초기화
          const fileNameEl = document.getElementById("selectedFileName");
          if (fileNameEl) {
            fileNameEl.textContent = "파일을 선택하세요";
            fileNameEl.classList.remove("selected");
          }
          // 층 추가 UI 숨김
          toggleAddFloorUI();
          onBuildingSelect();
        } else {
          showToast(res.detail || "층 추가에 실패했습니다.", "error");
        }
      } catch (error) {
        console.error("층 추가 오류:", error);
        showToast(error.message || "층 추가에 실패했습니다.", "error");
      }
    }

    function confirmDeleteFloor(floorNumber) {
      state.deleteTarget = { type: 'floor', floorNumber, buildingId: state.currentBuilding };
      document.getElementById("deleteModal").classList.add("show");
    }

    async function deleteFloor() {
      if (!state.deleteTarget || state.deleteTarget.type !== 'floor') return;

      const { buildingId, floorNumber } = state.deleteTarget;

      try {
        const res = await apiDeleteBuildingFloor(buildingId, floorNumber);
        if (res.code === 200) {
          showToast(`${formatFloorName(floorNumber)}이 삭제되었습니다.`);
          // 현재 편집 중인 층이 삭제된 경우 에디터 초기화
          if (state.currentFloor === floorNumber) {
            state.currentFloor = null;
            state.currentFloorData = null;
            document.getElementById("editorSection").style.display = "none";
            document.getElementById("editorPlaceholder").style.display = "block";
          }
          onBuildingSelect();
        } else {
          showToast(res.detail || "층 삭제에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("층 삭제에 실패했습니다.", "error");
      }

      document.getElementById("deleteModal").classList.remove("show");
      state.deleteTarget = null;
    }

    // ===== 콘텐츠 이미지 관리 함수 =====
    let currentContentType = "dashboard"; // dashboard 또는 pr

    function loadContentImages() {
      loadDashboardImages();
      loadPrImages();
    }
    function getFullImageUrl(imagePath) {
      if (!imagePath) return '';
      if (imagePath.startsWith('http://') || imagePath.startsWith('https://') || imagePath.startsWith('/')) {
        return imagePath;
      }
      return `${HOST}/${imagePath}`;
    }
    async function loadDashboardImages() {
      const grid = document.getElementById("dashboardImageGrid");
      grid.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

      try {
        const res = await apiGetDashboardImages();
        console.log('Dashboard images response:', res);
        if (res.code === 200) {
          // JSON 파일에서 직접 images 배열 가져오기
          const images = res.data?.images || res.data?.data?.images || [];
          renderDashboardImages(images);
        } else {
          throw new Error(res.message || '이미지를 불러올 수 없습니다.');
        }
      } catch (error) {
        console.error('Dashboard images load error:', error);
        grid.innerHTML = `
            <div class="empty-state">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
              </svg>
              <h3 class="empty-title">이미지를 불러올 수 없습니다</h3>
              <p class="empty-description">${error.message || '잠시 후 다시 시도해주세요.'}</p>
            </div>
          `;
      }
    }

    function renderDashboardImages(images) {
      const grid = document.getElementById("dashboardImageGrid");

      if (images.length === 0) {
        grid.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
              </svg>
              <h3 class="empty-title">등록된 메인 화면 이미지가 없습니다</h3>
              <p class="empty-description">상단에서 새 이미지를 업로드하세요.</p>
            </div>
          `;
        return;
      }

      grid.innerHTML = images
        .map(
          (img) => `
          <div class="image-card">
            <img src="${getFullImageUrl(img.path)}" alt="${img.name || img.filename}" class="image-preview" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23f3f4f6%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2250%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%239ca3af%22 font-size=%2212%22>이미지 없음</text></svg>'">
            <div class="image-info">
              <div class="image-name-editable" data-image-id="${img.id}" data-image-type="dashboard">
                <span class="image-name-display">${img.name || img.filename}</span>
                <input type="text" class="image-name-input" value="${img.name || img.filename}" style="display: none;" />
              </div>
              <div class="image-meta">${formatDate(img.created_at)}</div>
              <div class="image-actions">
                <button class="btn btn-secondary btn-sm" onclick="editImageName(${img.id}, 'dashboard')">
                  이름 변경
                </button>
                <button class="btn btn-danger btn-sm" onclick="confirmDeleteContentImage(${img.id}, 'dashboard')">
                  삭제
                </button>
              </div>
            </div>
          </div>
        `
        )
        .join("");

      // 이미지 이름 편집 이벤트 리스너 추가
      attachImageNameEditListeners('dashboard');
    }

    async function loadPrImages() {
      const grid = document.getElementById("prImageGrid");
      grid.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

      try {
        const res = await apiGetPrImages();
        console.log('PR images response:', res);
        if (res.code === 200) {
          // JSON 파일에서 직접 images 배열 가져오기
          const images = res.data?.images || res.data?.data?.images || [];
          renderPrImages(images);
        } else {
          throw new Error(res.message || '이미지를 불러올 수 없습니다.');
        }
      } catch (error) {
        console.error('PR images load error:', error);
        grid.innerHTML = `
            <div class="empty-state">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
              </svg>
              <h3 class="empty-title">이미지를 불러올 수 없습니다</h3>
              <p class="empty-description">${error.message || '잠시 후 다시 시도해주세요.'}</p>
            </div>
          `;
      }
    }

    function renderPrImages(images) {
      const grid = document.getElementById("prImageGrid");

      if (images.length === 0) {
        grid.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
              <svg class="empty-icon" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
              </svg>
              <h3 class="empty-title">등록된 홍보 화면 이미지가 없습니다</h3>
              <p class="empty-description">상단에서 새 이미지를 업로드하세요.</p>
            </div>
          `;
        return;
      }

      grid.innerHTML = images
        .map(
          (img) => `
          <div class="image-card">
            <img src="${getFullImageUrl(img.path)}" alt="${img.name || img.filename}" class="image-preview" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23f3f4f6%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2250%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%239ca3af%22 font-size=%2212%22>이미지 없음</text></svg>'">
            <div class="image-info">
              <div class="image-name-editable" data-image-id="${img.id}" data-image-type="pr">
                <span class="image-name-display">${img.name || img.filename}</span>
                <input type="text" class="image-name-input" value="${img.name || img.filename}" style="display: none;" />
              </div>
              <div class="image-meta">${formatDate(img.created_at)}</div>
              <div class="image-actions">
                <button class="btn btn-secondary btn-sm" onclick="editImageName(${img.id}, 'pr')">
                  이름 변경
                </button>
                <button class="btn btn-danger btn-sm" onclick="confirmDeleteContentImage(${img.id}, 'pr')">
                  삭제
                </button>
              </div>
            </div>
          </div>
        `
        )
        .join("");

      // 이미지 이름 편집 이벤트 리스너 추가
      attachImageNameEditListeners('pr');
    }

    function confirmDeleteContentImage(imageId, type) {
      state.deleteTarget = { imageId, type, isContentImage: true };
      document.querySelector("#deleteModal .modal-title").textContent = "이미지 삭제";
      document.querySelector("#deleteModal .modal-body p").textContent =
        "이 이미지를 삭제하시겠습니까? 삭제된 이미지는 복구할 수 없습니다.";
      document.getElementById("deleteModal").classList.add("show");
    }

    function editImageName(imageId, imageType) {
      const editable = document.querySelector(
        `.image-name-editable[data-image-id="${imageId}"][data-image-type="${imageType}"]`
      );
      if (!editable) return;

      const display = editable.querySelector('.image-name-display');
      const input = editable.querySelector('.image-name-input');

      if (display && input) {
        display.style.display = 'none';
        input.style.display = 'block';
        input.focus();
        input.select();

        // Enter 키로 저장
        input.onkeydown = async (e) => {
          if (e.key === 'Enter') {
            await saveImageName(imageId, imageType, input.value.trim());
          } else if (e.key === 'Escape') {
            input.value = display.textContent;
            display.style.display = 'block';
            input.style.display = 'none';
          }
        };

        // 포커스 아웃 시 저장
        input.onblur = async () => {
          await saveImageName(imageId, imageType, input.value.trim());
        };
      }
    }

    async function saveImageName(imageId, imageType, newName) {
      if (!newName) {
        showToast('이름을 입력해주세요.', 'error');
        return;
      }

      try {
        const apiFunc = imageType === 'dashboard'
          ? apiUpdateDashboardImageName
          : apiUpdatePrImageName;

        const res = await apiFunc(imageId, newName);

        if (res.code === 200) {
          showToast('이름이 변경되었습니다.', 'success');

          // UI 업데이트
          const editable = document.querySelector(
            `.image-name-editable[data-image-id="${imageId}"][data-image-type="${imageType}"]`
          );
          if (editable) {
            const display = editable.querySelector('.image-name-display');
            const input = editable.querySelector('.image-name-input');
            if (display && input) {
              display.textContent = newName;
              input.value = newName;
              display.style.display = 'block';
              input.style.display = 'none';
            }
          }

          // 이미지 목록 새로고침
          if (imageType === 'dashboard') {
            await loadDashboardImages();
          } else {
            await loadPrImages();
          }
        } else {
          showToast(res.message || '이름 변경에 실패했습니다.', 'error');
        }
      } catch (error) {
        console.error('이름 변경 오류:', error);
        showToast('이름 변경 중 오류가 발생했습니다.', 'error');
      }
    }

    function attachImageNameEditListeners(imageType) {
      // 이미지 이름 더블클릭으로 편집 가능
      const editables = document.querySelectorAll(
        `.image-name-editable[data-image-type="${imageType}"]`
      );
      editables.forEach(editable => {
        const display = editable.querySelector('.image-name-display');
        if (display) {
          display.onclick = () => {
            const imageId = editable.getAttribute('data-image-id');
            editImageName(parseInt(imageId), imageType);
          };
          display.style.cursor = 'pointer';
          display.title = '클릭하여 이름 변경';
        }
      });
    }

    async function deleteContentImage() {
      if (!state.deleteTarget || !state.deleteTarget.isContentImage) return;

      const { imageId, type } = state.deleteTarget;

      try {
        let res;
        if (type === "dashboard") {
          res = await apiDeleteDashboardImage(imageId);
        } else {
          res = await apiDeletePrImage(imageId);
        }

        if (res.code === 200) {
          showToast("이미지가 삭제되었습니다.");
          if (type === "dashboard") {
            loadDashboardImages();
          } else {
            loadPrImages();
          }
        } else {
          showToast(res.detail || "삭제에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("삭제에 실패했습니다.", "error");
      }

      document.getElementById("deleteModal").classList.remove("show");
      state.deleteTarget = null;
    }

    async function uploadDashboardImage(file) {
      try {
        const res = await apiUploadDashboardImage(file);
        if (res.code === 200) {
          showToast("이미지가 업로드되었습니다.");
          loadDashboardImages();
        } else {
          showToast(res.detail || "업로드에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("업로드에 실패했습니다.", "error");
      }
    }

    async function uploadPrImage(file) {
      try {
        const res = await apiUploadPrImage(file);
        if (res.code === 200) {
          showToast("이미지가 업로드되었습니다.");
          loadPrImages();
        } else {
          showToast(res.detail || "업로드에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("업로드에 실패했습니다.", "error");
      }
    }

    // 기존 호환성을 위한 함수 (deprecated)
    async function loadSlides() {
      loadContentImages();
    }

    function confirmDelete(slideId, mode) {
      // Legacy 함수 - 사용하지 않음
    }

    async function deleteSlide() {
      // Legacy 함수 - deleteContentImage로 대체
      if (state.deleteTarget && state.deleteTarget.isContentImage) {
        await deleteContentImage();
      }
    }

    // ===== 테마 관리 함수 =====
    let themesData = null;

    async function loadThemes() {
      try {
        const res = await apiGetThemes();
        if (res.code === 200) {
          themesData = res.data;
          renderThemeGrid();
          applyTheme(themesData.currentTheme);
        }
      } catch (error) {
        console.error("테마 로드 실패:", error);
      }
    }

    function renderThemeGrid() {
      const themeGrid = document.getElementById("themeGrid");
      if (!themeGrid || !themesData) return;

      const themes = themesData.themes;
      const currentTheme = themesData.currentTheme;

      themeGrid.innerHTML = Object.values(themes).map(theme => `
          <div class="theme-card ${theme.id === currentTheme ? 'active' : ''}" 
               data-theme-id="${theme.id}"
               onclick="selectTheme('${theme.id}')">
            <div class="theme-preview">
              <div class="theme-preview-sidebar" style="background: ${theme.colors.sidebarBg};"></div>
              <div class="theme-preview-content" style="background: ${theme.colors.bgMain};">
                <div class="theme-preview-header" style="background: ${theme.colors.primary};"></div>
                <div class="theme-preview-card" style="background: ${theme.colors.bgCard}; border: 1px solid ${theme.colors.borderDefault};">
                  <div class="theme-preview-btn" style="background: ${theme.colors.primary};"></div>
                </div>
              </div>
            </div>
            <div class="theme-info">
              <div class="theme-name">${theme.name}</div>
              <div class="theme-description">${theme.description}</div>
            </div>
            <div class="theme-colors">
              <div class="theme-color-dot" style="background: ${theme.colors.primary};" title="Primary"></div>
              <div class="theme-color-dot" style="background: ${theme.colors.success};" title="Success"></div>
              <div class="theme-color-dot" style="background: ${theme.colors.danger};" title="Danger"></div>
              <div class="theme-color-dot" style="background: ${theme.colors.warning};" title="Warning"></div>
            </div>
          </div>
        `).join('');
    }

    async function selectTheme(themeId) {
      if (!themesData || themesData.currentTheme === themeId) return;

      try {
        const res = await apiSetTheme(themeId);
        if (res.code === 200) {
          themesData.currentTheme = themeId;
          applyTheme(themeId);
          renderThemeGrid();
          showToast(`"${themesData.themes[themeId].name}" 테마가 적용되었습니다.`);
        } else {
          showToast("테마 변경에 실패했습니다.", "error");
        }
      } catch (error) {
        showToast("테마 변경에 실패했습니다.", "error");
      }
    }

    function applyTheme(themeId) {
      if (!themesData || !themesData.themes[themeId]) return;

      const theme = themesData.themes[themeId];
      const colors = theme.colors;
      const root = document.documentElement;

      // 시맨틱 색상 변수 업데이트
      root.style.setProperty('--primary', colors.primary);
      root.style.setProperty('--primary-dark', colors.primaryDark);
      root.style.setProperty('--primary-light', colors.primaryLight);
      root.style.setProperty('--danger', colors.danger);
      root.style.setProperty('--danger-dark', colors.dangerDark);
      root.style.setProperty('--danger-light', colors.dangerLight);
      root.style.setProperty('--success', colors.success);
      root.style.setProperty('--success-light', colors.successLight);
      root.style.setProperty('--warning', colors.warning);
      root.style.setProperty('--warning-light', colors.warningLight);

      // 배경 및 텍스트 색상
      root.style.setProperty('--bg-main', colors.bgMain);
      root.style.setProperty('--bg-card', colors.bgCard);
      root.style.setProperty('--text-primary', colors.textPrimary);
      root.style.setProperty('--text-secondary', colors.textSecondary);
      root.style.setProperty('--border-default', colors.borderDefault);

      // 사이드바 색상
      root.style.setProperty('--sidebar-bg', colors.sidebarBg);
      root.style.setProperty('--sidebar-text', colors.sidebarText);
      root.style.setProperty('--sidebar-active-text', colors.sidebarActiveText);
      root.style.setProperty('--sidebar-active-bg', colors.sidebarActiveBg);

      // 로고 색상
      root.style.setProperty('--logo-color', colors.logoColor);
      root.style.setProperty('--logo-color-inverse', colors.logoColorInverse);

      // 현위치 색상
      root.style.setProperty('--current-location', colors.currentLocation);
      root.style.setProperty('--current-location-dark', colors.currentLocationDark);

      // 투명도 색상 업데이트
      const primaryRgb = hexToRgb(colors.primary);
      if (primaryRgb) {
        root.style.setProperty('--primary-alpha-10', `rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, 0.1)`);
        root.style.setProperty('--primary-alpha-15', `rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, 0.15)`);
        root.style.setProperty('--primary-alpha-20', `rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, 0.2)`);
      }

      // body 배경색 업데이트
      document.body.style.background = colors.bgMain;
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    // ===== 이벤트 리스너 =====
    document.addEventListener("DOMContentLoaded", () => {
      // 페이지 로드 시 테마 적용 (로그인 페이지 포함)
      loadThemes();

      // 로그인 폼 - JWT 기반
      document.getElementById("loginForm").addEventListener("submit", async (e) => {
        e.preventDefault();

        const username = document.getElementById("username").value;
        const password = document.getElementById("password").value;
        const errorEl = document.getElementById("loginError");
        const loginBtn = document.getElementById("loginBtn");

        loginBtn.disabled = true;
        loginBtn.textContent = "로그인 중...";
        errorEl.classList.remove("show");

        try {
          const result = await Auth.login(username, password);

          if (result.success) {
            state.isLoggedIn = true;
            state.user = result.user;

            // 사용자 정보 업데이트
            if (result.user.name) {
              document.getElementById("userName").textContent = result.user.name;
              document.getElementById("userAvatar").textContent = result.user.name.charAt(0);
            }

            Router.navigate('dashboard');
            showToast(`${result.user.name || result.user.username}님, 환영합니다!`);
          } else {
            errorEl.textContent = result.message;
            errorEl.classList.add("show");
          }
        } catch (error) {
          console.error("로그인 오류:", error);
          errorEl.textContent = "서버에 연결할 수 없습니다.";
          errorEl.classList.add("show");
        }

        loginBtn.disabled = false;
        loginBtn.textContent = "로그인";
      });

      // 로그아웃 - JWT 기반
      document.getElementById("logoutBtn").addEventListener("click", async () => {
        await Auth.logout();
        state.isLoggedIn = false;
        state.user = null;
        Router.navigate('login');
        showToast("로그아웃되었습니다.");
      });

      // 네비게이션 - Hash 라우터가 처리하므로 별도 클릭 이벤트 불필요
      // a 태그의 href="#page" 로 자동 처리됨

      // 콘텐츠 탭 전환
      document.querySelectorAll(".content-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".content-tab").forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          currentContentType = tab.dataset.contentType;

          // 섹션 표시/숨김 전환
          if (currentContentType === "dashboard") {
            document.getElementById("dashboardImagesSection").style.display = "block";
            document.getElementById("prImagesSection").style.display = "none";
          } else {
            document.getElementById("dashboardImagesSection").style.display = "none";
            document.getElementById("prImagesSection").style.display = "block";
          }
        });
      });

      // 대시보드 이미지 업로드
      const dashboardUploadZone = document.getElementById("dashboardUploadZone");
      const dashboardFileInput = document.getElementById("dashboardFileInput");

      if (dashboardUploadZone) {
        dashboardUploadZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dashboardUploadZone.classList.add("dragover");
        });

        dashboardUploadZone.addEventListener("dragleave", () => {
          dashboardUploadZone.classList.remove("dragover");
        });

        dashboardUploadZone.addEventListener("drop", async (e) => {
          e.preventDefault();
          dashboardUploadZone.classList.remove("dragover");

          const files = e.dataTransfer.files;
          for (const file of files) {
            await handleDashboardUpload(file);
          }
        });
      }

      if (dashboardFileInput) {
        dashboardFileInput.addEventListener("change", async (e) => {
          const files = e.target.files;
          for (const file of files) {
            await handleDashboardUpload(file);
          }
          dashboardFileInput.value = "";
        });
      }

      // 홍보 이미지 업로드
      const prUploadZone = document.getElementById("prUploadZone");
      const prFileInput = document.getElementById("prFileInput");

      if (prUploadZone) {
        prUploadZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          prUploadZone.classList.add("dragover");
        });

        prUploadZone.addEventListener("dragleave", () => {
          prUploadZone.classList.remove("dragover");
        });

        prUploadZone.addEventListener("drop", async (e) => {
          e.preventDefault();
          prUploadZone.classList.remove("dragover");

          const files = e.dataTransfer.files;
          for (const file of files) {
            await handlePrUpload(file);
          }
        });
      }

      if (prFileInput) {
        prFileInput.addEventListener("change", async (e) => {
          const files = e.target.files;
          for (const file of files) {
            await handlePrUpload(file);
          }
          prFileInput.value = "";
        });
      }

      async function handleDashboardUpload(file) {
        if (!file.type.startsWith("image/")) {
          showToast("이미지 파일만 업로드할 수 있습니다.", "error");
          return;
        }

        if (file.size > 10 * 1024 * 1024) {
          showToast("파일 크기는 10MB를 초과할 수 없습니다.", "error");
          return;
        }

        try {
          // 리사이즈 모달 열기
          await openContentResizeModal(file, 'dashboard');
          // 모달에서 확인 버튼을 누르면 업로드가 진행됨
        } catch (error) {
          if (error.message !== '사용자가 취소했습니다.') {
            showToast(error.message || "이미지 처리에 실패했습니다.", "error");
          }
        }
      }

      async function handlePrUpload(file) {
        if (!file.type.startsWith("image/")) {
          showToast("이미지 파일만 업로드할 수 있습니다.", "error");
          return;
        }

        if (file.size > 10 * 1024 * 1024) {
          showToast("파일 크기는 10MB를 초과할 수 없습니다.", "error");
          return;
        }

        try {
          // 리사이즈 모달 열기
          await openContentResizeModal(file, 'pr');
          // 모달에서 확인 버튼을 누르면 업로드가 진행됨
        } catch (error) {
          if (error.message !== '사용자가 취소했습니다.') {
            showToast(error.message || "이미지 처리에 실패했습니다.", "error");
          }
        }
      }

      // 삭제 모달
      document.getElementById("cancelDeleteBtn").addEventListener("click", () => {
        document.getElementById("deleteModal").classList.remove("show");
        state.deleteTarget = null;
      });

      document.getElementById("confirmDeleteBtn").addEventListener("click", () => {
        if (state.deleteTarget?.type === 'building') {
          deleteBuilding();
        } else if (state.deleteTarget?.type === 'floor') {
          deleteFloor();
        } else if (state.deleteTarget?.isContentImage) {
          deleteContentImage();
        } else {
          deleteSlide();
        }
      });

      // 모달 외부 클릭으로 닫기
      document.getElementById("deleteModal").addEventListener("click", (e) => {
        if (e.target.id === "deleteModal") {
          document.getElementById("deleteModal").classList.remove("show");
          state.deleteTarget = null;
        }
      });

      // 이미지 경로를 전체 URL로 변환하는 헬퍼 함수


      // 층 번호 가져오기 헬퍼 함수
      function getSelectedFloorNumber() {
        return parseInt(document.getElementById("floorSelect").value) || null;
      }

      // 건물 관리 이벤트
      document.getElementById("createBuildingBtn").addEventListener("click", createBuilding);
      document.getElementById("refreshBuildingsBtn").addEventListener("click", loadBuildings);
      document.getElementById("migrateDataBtn").addEventListener("click", migrateLegacyData);

      // 청사도 관리 이벤트
      document.getElementById("buildingSelect").addEventListener("change", onBuildingSelect);
      document.getElementById("floorSelect").addEventListener("change", onFloorSelect);
      document.getElementById("floorUpBtn").addEventListener("click", incrementFloorNumber);
      document.getElementById("floorDownBtn").addEventListener("click", decrementFloorNumber);
      document.getElementById("addFloorBtn").addEventListener("click", addFloor);

      // 파일 선택 시 리사이즈 모달 열기
      document.getElementById("newFloorImage").addEventListener("change", async function () {
        const fileNameEl = document.getElementById("selectedFileName");

        if (this.files.length > 0) {
          const file = this.files[0];

          // SVG 파일은 리사이즈 없이 바로 사용
          if (file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')) {
            state.resizedFloorImage = file;
            if (fileNameEl) {
              fileNameEl.textContent = file.name;
              fileNameEl.classList.add("selected");
            }
            showToast("SVG 파일이 선택되었습니다.");
            return;
          }

          try {
            // 리사이즈 모달 열기
            const resizedFile = await openImageResizeModal(file);
            state.resizedFloorImage = resizedFile;
            if (fileNameEl) {
              fileNameEl.textContent = file.name + " (800×600 조정됨)";
              fileNameEl.classList.add("selected");
            }
            showToast("이미지가 800×600으로 조정되었습니다.");
          } catch (e) {
            // 사용자가 취소한 경우
            this.value = ""; // 파일 선택 초기화
            state.resizedFloorImage = null;
            if (fileNameEl) {
              fileNameEl.textContent = "파일을 선택하세요";
              fileNameEl.classList.remove("selected");
            }
          }
        } else {
          state.resizedFloorImage = null;
          if (fileNameEl) {
            fileNameEl.textContent = "파일을 선택하세요";
            fileNameEl.classList.remove("selected");
          }
        }
      });

      // JSON 불러오기 버튼
      document.getElementById("importJsonBtn").addEventListener("click", () => {
        document.getElementById("importJsonInput").click();
      });

      // JSON 파일 선택 시 좌표 불러오기
      document.getElementById("importJsonInput").addEventListener("change", async function () {
        if (!this.files.length) return;

        const file = this.files[0];
        const reader = new FileReader();

        reader.onload = async (e) => {
          try {
            const jsonData = JSON.parse(e.target.result);

            // 층 번호 확인
            const floorNumber = jsonData.floor || getSelectedFloorNumber();
            if (!floorNumber) {
              showToast("JSON에 층 번호가 없습니다. 층을 먼저 선택해주세요.", "error");
              return;
            }

            // 기존 층이 선택되어 있으면 데이터 병합
            if (state.currentFloorData) {
              if (jsonData.elements) {
                state.currentFloorData.elements = jsonData.elements;
              }
              if (jsonData.currentLocation) {
                state.currentFloorData.currentLocation = jsonData.currentLocation;
              }
              if (jsonData.iconTypes) {
                state.currentFloorData.iconTypes = jsonData.iconTypes;
              }
              // buildingId 보장
              if (!state.currentFloorData.buildingId && state.currentBuilding) {
                state.currentFloorData.buildingId = state.currentBuilding;
              }
              window.renderFloorElements();
              showToast("JSON 좌표 데이터를 불러왔습니다. 저장 버튼을 눌러 적용하세요.");
            } else {
              if (!state.currentBuilding) {
                showToast("건물을 먼저 선택해주세요.", "error");
                return;
              }
              state.currentFloor = floorNumber;
              state.currentFloorData = jsonData;
              // buildingId 보장
              if (!state.currentFloorData.buildingId) {
                state.currentFloorData.buildingId = state.currentBuilding;
              }
              // floor 필드 보장
              if (!state.currentFloorData.floor) {
                state.currentFloorData.floor = floorNumber;
              }
              document.getElementById("floorSelect").value = floorNumber;
              loadFloorPlanEditor();
              showToast(`${formatFloorName(floorNumber)} JSON 데이터를 불러왔습니다.`);
            }
          } catch (error) {
            showToast("JSON 파일을 파싱할 수 없습니다.", "error");
          }
        };

        reader.readAsText(file);
        this.value = "";
      });

      // JSON 내보내기
      document.getElementById("exportJsonBtn").addEventListener("click", () => {
        if (!state.currentFloorData) {
          showToast("내보낼 데이터가 없습니다.", "error");
          return;
        }

        // currentLocation 위치 업데이트
        updateCurrentLocationPosition();

        const exportData = {
          buildingId: state.currentBuilding,
          floor: state.currentFloor,
          floorName: state.currentFloorData.floorName,
          imageSize: state.currentFloorData.imageSize,
          iconTypes: state.currentFloorData.iconTypes,
          elements: state.currentFloorData.elements,
          currentLocation: state.currentFloorData.currentLocation,
          exportedAt: new Date().toISOString()
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `building_${state.currentBuilding}_floor_${state.currentFloor}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast("JSON 파일이 다운로드되었습니다.");
      });

      // 이미지 내보내기 (캔버스를 이미지로)
      document.getElementById("exportImageBtn").addEventListener("click", async () => {
        if (!state.currentFloorData) {
          showToast("내보낼 데이터가 없습니다.", "error");
          return;
        }

        try {
          const canvas = document.getElementById("floorPlanCanvas");
          const image = document.getElementById("floorPlanImage");

          // html2canvas 대신 간단한 방법 사용
          // 청사도 이미지만 다운로드
          const imageSrc = image.src;
          if (!imageSrc) {
            showToast("내보낼 이미지가 없습니다.", "error");
            return;
          }

          // 이미지 다운로드
          const a = document.createElement("a");
          a.href = imageSrc;
          a.download = `floor_${state.currentFloor}_image.png`;

          // CORS 문제가 있을 수 있으므로 fetch로 시도
          try {
            const response = await fetch(imageSrc);
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast("이미지 파일이 다운로드되었습니다.");
          } catch (fetchError) {
            // fetch 실패 시 직접 링크 열기
            a.target = "_blank";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast("이미지 파일이 다운로드되었습니다.");
          }
        } catch (error) {
          showToast("이미지 내보내기에 실패했습니다.", "error");
        }
      });

      // 스케일 계산 헬퍼 함수 (캔버스 렌더링 크기 vs imageSize 원본 크기)
      function getEditorScale() {
        const canvas = document.getElementById("floorPlanCanvas");
        const imageSize = state.currentFloorData?.imageSize || { width: 931, height: 330 };
        const canvasRect = canvas.getBoundingClientRect();
        return {
          x: canvasRect.width / imageSize.width,
          y: canvasRect.height / imageSize.height,
          imageSize: imageSize
        };
      }

      // 전역에서 접근 가능하도록 window 객체에 할당
      window.loadFloorPlanEditor = function () {
        if (!state.currentFloorData) return;

        const editorSection = document.getElementById("editorSection");
        const editorPlaceholder = document.getElementById("editorPlaceholder");
        const canvas = document.getElementById("floorPlanCanvas");
        const image = document.getElementById("floorPlanImage");
        const elementsContainer = document.getElementById("floorPlanElements");
        const currentFloorTitle = document.getElementById("currentFloorTitle");
        const currentFloorBadge = document.getElementById("currentFloorBadge");

        // 에디터 표시, 플레이스홀더 숨김
        editorSection.style.display = "block";
        if (editorPlaceholder) editorPlaceholder.style.display = "none";

        // 타이틀 업데이트
        const building = state.buildings.find(b => b.id === state.currentBuilding);
        if (currentFloorTitle) currentFloorTitle.textContent = building ? building.name : "청사도";
        if (currentFloorBadge) currentFloorBadge.textContent = formatFloorName(state.currentFloor);

        // 툴바 층 정보 업데이트
        updateToolbarFloorInfo();

        // 층 목록에서 선택 상태 업데이트
        renderFloorList();

        // 이미지 로드 (전체 URL로 변환)
        image.src = getFullImageUrl(state.currentFloorData.floorImage) || "";
        image.onload = () => {
          const imageSize = state.currentFloorData.imageSize || { width: image.naturalWidth, height: image.naturalHeight };
          canvas.style.width = `${imageSize.width}px`;
          canvas.style.height = `${imageSize.height}px`;
          elementsContainer.style.width = `${imageSize.width}px`;
          elementsContainer.style.height = `${imageSize.height}px`;

          const currentLocationContainer = document.getElementById("currentLocationElement");
          currentLocationContainer.style.width = `${imageSize.width}px`;
          currentLocationContainer.style.height = `${imageSize.height}px`;

          window.window.renderFloorElements();
        };
      };

      window.renderFloorElements = function () {
        if (!state.currentFloorData) return;

        const elementsContainer = document.getElementById("floorPlanElements");
        elementsContainer.innerHTML = "";

        // currentLocation 아이콘은 제외하고 렌더링
        const elements = (state.currentFloorData.elements || []).filter(
          (e) => !(e.type === "icon" && e.iconType === "currentLocation")
        );
        elements.forEach((element) => {
          const el = createFloorElement(element);
          elementsContainer.appendChild(el);
        });

        // currentLocation 별도 렌더링
        renderCurrentLocation();
      }

      function renderCurrentLocation() {
        if (!state.currentFloorData) return;

        const currentLocation = state.currentFloorData.currentLocation || {};
        const container = document.getElementById("currentLocationElement");

        if (!currentLocation.enabled) {
          container.style.display = "none";
          return;
        }

        // 스케일 적용하여 표시 (imageSize 기준 좌표를 캔버스 크기에 맞게 변환)
        const scale = getEditorScale();
        container.style.display = "block";
        container.style.left = `${currentLocation.x1 * scale.x}px`;
        container.style.top = `${currentLocation.y1 * scale.y}px`;
        container.style.width = `${(currentLocation.x2 - currentLocation.x1) * scale.x}px`;
        container.style.height = `${(currentLocation.y2 - currentLocation.y1) * scale.y}px`;

        container.innerHTML = "";

        // currentLocation 자체의 icon 필드 사용 (전체 URL로 변환)
        const iconPath = currentLocation.icon || "images/icons/current_location.svg";
        const iconImg = document.createElement("img");
        iconImg.src = getFullImageUrl(iconPath);
        iconImg.alt = "현위치";
        iconImg.style.width = "100%";
        iconImg.style.height = "100%";
        iconImg.style.objectFit = "contain";
        container.appendChild(iconImg);

        if (currentLocation.showLabel && currentLocation.labelText) {
          const label = document.createElement("div");
          label.className = "label";
          label.textContent = currentLocation.labelText;
          if (currentLocation.labelStyle) {
            label.style.fontSize = `${currentLocation.labelStyle.fontSize || 11}px`;
            label.style.color = currentLocation.labelStyle.color || THEME.textDark;
            label.style.backgroundColor = currentLocation.labelStyle.backgroundColor || THEME.currentLocation;
            label.style.borderRadius = `${currentLocation.labelStyle.borderRadius || 12}px`;
          }
          container.appendChild(label);
        }

        container.className = "current-location-element";
        container.style.pointerEvents = "all";

        // 클릭 이벤트
        container.addEventListener("click", () => {
          selectCurrentLocation();
        });

        // 드래그 이벤트
        setupCurrentLocationDrag(container);
      }

      // 현위치 전용 드래그 매니저 (성능 최적화)
      const currentLocationDragManager = {
        isDragging: false,
        element: null,
        startX: 0,
        startY: 0,
        startLeft: 0,
        startTop: 0,
        containerRect: null,
        elementWidth: 0,
        elementHeight: 0,
        rafId: null,
        pendingX: 0,
        pendingY: 0,

        start(element, e) {
          this.isDragging = true;
          this.element = element;

          const rect = element.getBoundingClientRect();
          this.containerRect = document.getElementById("floorPlanCanvas").getBoundingClientRect();
          this.startX = e.clientX;
          this.startY = e.clientY;
          this.startLeft = rect.left - this.containerRect.left;
          this.startTop = rect.top - this.containerRect.top;
          this.elementWidth = element.offsetWidth;
          this.elementHeight = element.offsetHeight;

          element.classList.add("dragging");
          element.style.cursor = "grabbing";
          e.preventDefault();
        },

        move(e) {
          if (!this.isDragging) return;

          this.pendingX = this.startLeft + (e.clientX - this.startX);
          this.pendingY = this.startTop + (e.clientY - this.startY);

          if (!this.rafId) {
            this.rafId = requestAnimationFrame(() => this.updatePosition());
          }
        },

        updatePosition() {
          this.rafId = null;
          if (!this.isDragging || !this.element) return;

          const maxX = this.containerRect.width - this.elementWidth;
          const maxY = this.containerRect.height - this.elementHeight;

          const newLeft = Math.max(0, Math.min(this.pendingX, maxX));
          const newTop = Math.max(0, Math.min(this.pendingY, maxY));

          this.element.style.left = `${newLeft}px`;
          this.element.style.top = `${newTop}px`;
        },

        end() {
          if (!this.isDragging) return;

          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }

          this.element.classList.remove("dragging");
          this.element.style.cursor = "move";
          updateCurrentLocationPosition();

          this.isDragging = false;
          this.element = null;
        }
      };

      // 현위치 전역 이벤트 리스너
      document.addEventListener("mousemove", (e) => currentLocationDragManager.move(e));
      document.addEventListener("mouseup", () => currentLocationDragManager.end());

      function setupCurrentLocationDrag(element) {
        element.addEventListener("mousedown", (e) => {
          currentLocationDragManager.start(element, e);
        });
      }

      function selectCurrentLocation() {
        document.querySelectorAll(".floor-element, .current-location-element").forEach((el) => {
          el.classList.remove("selected");
        });
        const element = document.getElementById("currentLocationElement");
        if (element) {
          element.classList.add("selected");
          state.selectedElement = "currentLocation";
        }
      }

      function updateCurrentLocationPosition() {
        if (!state.currentFloorData) return;
        const element = document.getElementById("currentLocationElement");
        if (!element) return;

        const rect = element.getBoundingClientRect();
        const containerRect = document.getElementById("floorPlanCanvas").getBoundingClientRect();

        // 스케일을 역으로 적용하여 imageSize 기준 좌표로 저장
        const scale = getEditorScale();
        const x1 = (rect.left - containerRect.left) / scale.x;
        const y1 = (rect.top - containerRect.top) / scale.y;
        const x2 = x1 + (rect.width / scale.x);
        const y2 = y1 + (rect.height / scale.y);

        if (state.currentFloorData.currentLocation) {
          state.currentFloorData.currentLocation.x1 = Math.round(x1);
          state.currentFloorData.currentLocation.y1 = Math.round(y1);
          state.currentFloorData.currentLocation.x2 = Math.round(x2);
          state.currentFloorData.currentLocation.y2 = Math.round(y2);
        }
      }

      function createFloorElement(elementData) {
        const div = document.createElement("div");
        div.className = `floor-element ${elementData.type}-element`;
        div.dataset.elementId = elementData.id;

        // 스케일 적용하여 표시 (imageSize 기준 좌표를 캔버스 크기에 맞게 변환)
        const scale = getEditorScale();
        div.style.left = `${elementData.x1 * scale.x}px`;
        div.style.top = `${elementData.y1 * scale.y}px`;
        div.style.width = `${(elementData.x2 - elementData.x1) * scale.x}px`;
        div.style.height = `${(elementData.y2 - elementData.y1) * scale.y}px`;

        if (elementData.type === "text") {
          div.textContent = elementData.text || "";
          if (elementData.style) {
            const scaledFontSize = Math.max(8, Math.round((elementData.style.fontSize || 12) * Math.min(scale.x, scale.y)));
            div.style.fontSize = `${scaledFontSize}px`;
            div.style.color = elementData.style.color || THEME.textDefault;
            div.style.fontFamily = elementData.style.fontFamily || "Pretendard";
            div.style.fontWeight = elementData.style.fontWeight || "normal";
          }
        } else if (elementData.type === "icon") {
          const iconTypes = state.currentFloorData.iconTypes || {};
          const iconType = iconTypes[elementData.iconType];
          if (iconType) {
            const img = document.createElement("img");
            img.src = getFullImageUrl(iconType.icon);
            img.alt = iconType.label || "";
            div.appendChild(img);
          }
        }

        // 삭제 버튼
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-btn";
        deleteBtn.textContent = "×";
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteElement(elementData.id);
        };
        div.appendChild(deleteBtn);

        // 클릭 이벤트
        div.addEventListener("click", (e) => {
          if (e.target !== deleteBtn) {
            selectElement(elementData.id);
          }
        });

        // 텍스트 요소 더블클릭 시 편집 기능
        if (elementData.type === "text") {
          div.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            enableTextEdit(div, elementData);
          });
        }

        // 드래그 이벤트
        setupDragAndDrop(div, elementData);

        return div;
      }

      // 텍스트 요소 인라인 편집 함수
      function enableTextEdit(element, elementData) {
        // 기존 텍스트 숨기기
        const originalText = elementData.text || "";
        element.textContent = "";

        // 입력 필드 생성
        const input = document.createElement("input");
        input.type = "text";
        input.value = originalText;
        input.style.cssText = `
            width: 100%;
            height: 100%;
            border: 2px solid var(--primary);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: inherit;
            font-family: inherit;
            font-weight: inherit;
            color: inherit;
            background: rgba(255, 255, 255, 0.95);
            outline: none;
            box-sizing: border-box;
          `;

        element.appendChild(input);
        input.focus();
        input.select();

        // 삭제 버튼 다시 추가
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-btn";
        deleteBtn.textContent = "×";
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteElement(elementData.id);
        };
        element.appendChild(deleteBtn);

        // 편집 완료 처리
        const finishEdit = () => {
          const newText = input.value.trim();
          if (newText) {
            // 상태 업데이트
            const elemIdx = state.currentFloorData.elements.findIndex(e => e.id === elementData.id);
            if (elemIdx !== -1) {
              state.currentFloorData.elements[elemIdx].text = newText;
            }
          }
          window.renderFloorElements();
        };

        // Enter로 완료
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            finishEdit();
          } else if (e.key === "Escape") {
            e.preventDefault();
            window.renderFloorElements();
          }
        });

        // 포커스 아웃 시 완료
        input.addEventListener("blur", finishEdit);
      }

      // 전역 드래그 매니저 (성능 최적화)
      const dragManager = {
        isDragging: false,
        element: null,
        elementData: null,
        startX: 0,
        startY: 0,
        startLeft: 0,
        startTop: 0,
        containerRect: null,
        elementWidth: 0,
        elementHeight: 0,
        rafId: null,
        pendingX: 0,
        pendingY: 0,

        start(element, elementData, e) {
          if (e.target.classList.contains("delete-btn")) return;

          this.isDragging = true;
          this.element = element;
          this.elementData = elementData;

          // 드래그 시작 시 필요한 값들 캐싱
          const rect = element.getBoundingClientRect();
          this.containerRect = document.getElementById("floorPlanCanvas").getBoundingClientRect();
          this.startX = e.clientX;
          this.startY = e.clientY;
          this.startLeft = rect.left - this.containerRect.left;
          this.startTop = rect.top - this.containerRect.top;

          // 요소 크기 캐싱
          const scale = getEditorScale();
          this.elementWidth = (elementData.x2 - elementData.x1) * scale.x;
          this.elementHeight = (elementData.y2 - elementData.y1) * scale.y;

          element.classList.add("dragging");
          element.style.cursor = "grabbing";
          e.preventDefault();
        },

        move(e) {
          if (!this.isDragging) return;

          // 새 위치 계산
          this.pendingX = this.startLeft + (e.clientX - this.startX);
          this.pendingY = this.startTop + (e.clientY - this.startY);

          // requestAnimationFrame으로 렌더링 최적화
          if (!this.rafId) {
            this.rafId = requestAnimationFrame(() => this.updatePosition());
          }
        },

        updatePosition() {
          this.rafId = null;
          if (!this.isDragging || !this.element) return;

          const maxX = this.containerRect.width - this.elementWidth;
          const maxY = this.containerRect.height - this.elementHeight;

          const newLeft = Math.max(0, Math.min(this.pendingX, maxX));
          const newTop = Math.max(0, Math.min(this.pendingY, maxY));

          this.element.style.left = `${newLeft}px`;
          this.element.style.top = `${newTop}px`;
        },

        end() {
          if (!this.isDragging) return;

          if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }

          this.element.classList.remove("dragging");
          this.element.style.cursor = "move";

          if (this.elementData) {
            updateElementPosition(this.elementData.id);
          }

          this.isDragging = false;
          this.element = null;
          this.elementData = null;
        }
      };

      // 전역 이벤트 리스너 (한 번만 등록)
      document.addEventListener("mousemove", (e) => dragManager.move(e));
      document.addEventListener("mouseup", () => dragManager.end());

      function setupDragAndDrop(element, elementData) {
        element.addEventListener("mousedown", (e) => {
          dragManager.start(element, elementData, e);
        });
      }

      function selectElement(elementId) {
        document.querySelectorAll(".floor-element").forEach((el) => {
          el.classList.remove("selected");
        });
        const element = document.querySelector(`[data-element-id="${elementId}"]`);
        if (element) {
          element.classList.add("selected");
          state.selectedElement = elementId;
        }
      }

      function updateElementPosition(elementId) {
        const element = document.querySelector(`[data-element-id="${elementId}"]`);
        if (!element || !state.currentFloorData) return;

        const rect = element.getBoundingClientRect();
        const containerRect = document.getElementById("floorPlanCanvas").getBoundingClientRect();

        // 스케일을 역으로 적용하여 imageSize 기준 좌표로 저장
        const scale = getEditorScale();
        const x1 = (rect.left - containerRect.left) / scale.x;
        const y1 = (rect.top - containerRect.top) / scale.y;
        const x2 = x1 + (rect.width / scale.x);
        const y2 = y1 + (rect.height / scale.y);

        const elementData = state.currentFloorData.elements.find((e) => e.id === elementId);
        if (elementData) {
          elementData.x1 = Math.round(x1);
          elementData.y1 = Math.round(y1);
          elementData.x2 = Math.round(x2);
          elementData.y2 = Math.round(y2);
        }
      }

      function deleteElement(elementId) {
        if (!state.currentFloorData) return;
        state.currentFloorData.elements = state.currentFloorData.elements.filter((e) => e.id !== elementId);
        window.renderFloorElements();
      }

      // 요소 편집 모달
      document.getElementById("addElementBtn").addEventListener("click", () => {
        if (!state.currentFloorData) {
          showToast("먼저 층 데이터를 불러오세요.", "error");
          return;
        }
        document.getElementById("addElementModal").classList.add("show");
        state.addElementType = null;
        state.addElementIconType = null;
        document.getElementById("textElementForm").style.display = "none";
        document.getElementById("iconElementForm").style.display = "none";
        document.querySelectorAll(".element-type-btn").forEach((btn) => btn.classList.remove("selected"));
      });

      document.querySelectorAll(".element-type-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".element-type-btn").forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          state.addElementType = btn.dataset.type;

          if (state.addElementType === "text") {
            document.getElementById("textElementForm").style.display = "block";
            document.getElementById("iconElementForm").style.display = "none";
          } else if (state.addElementType === "icon") {
            document.getElementById("textElementForm").style.display = "none";
            document.getElementById("iconElementForm").style.display = "block";
            loadIconTypes();
          }
        });
      });

      function loadIconTypes() {
        if (!state.currentFloorData) return;
        const iconTypes = state.currentFloorData.iconTypes || {};
        const container = document.getElementById("iconTypeSelector");
        container.innerHTML = "";

        Object.keys(iconTypes).forEach((key) => {
          // currentLocation은 아이콘 요소로 추가할 수 없음
          if (key === "currentLocation") return;

          const iconType = iconTypes[key];
          const btn = document.createElement("div");
          btn.className = "icon-type-btn";
          btn.dataset.iconType = key;
          btn.innerHTML = `
              <img src="${getFullImageUrl(iconType.icon)}" alt="${iconType.label}" />
              <span>${iconType.label}</span>
            `;
          btn.addEventListener("click", () => {
            document.querySelectorAll(".icon-type-btn").forEach((b) => b.classList.remove("selected"));
            btn.classList.add("selected");
            state.addElementIconType = key;
          });
          container.appendChild(btn);
        });
      }

      document.getElementById("confirmAddElementBtn").addEventListener("click", () => {
        if (!state.addElementType) {
          showToast("요소 타입을 선택해주세요.", "error");
          return;
        }

        if (!state.currentFloorData) return;

        const elements = state.currentFloorData.elements || [];
        const newId = `element${state.currentFloor}f${String(elements.length + 1).padStart(3, "0")}`;

        let newElement;
        if (state.addElementType === "text") {
          const text = document.getElementById("elementText").value || "새 텍스트";
          const fontSize = parseInt(document.getElementById("elementFontSize").value) || 12;
          const color = document.getElementById("elementColor").value || THEME.textDefault;

          newElement = {
            id: newId,
            type: "text",
            text: text,
            x1: 50,
            y1: 50,
            x2: 150,
            y2: 80,
            style: {
              fontSize: fontSize,
              fontFamily: "Pretendard",
              fontWeight: "normal",
              color: color,
            },
          };
        } else if (state.addElementType === "icon") {
          if (!state.addElementIconType) {
            showToast("아이콘 타입을 선택해주세요.", "error");
            return;
          }

          newElement = {
            id: newId,
            type: "icon",
            iconType: state.addElementIconType,
            x1: 50,
            y1: 50,
            x2: 80,
            y2: 80,
          };
        }

        elements.push(newElement);
        state.currentFloorData.elements = elements;
        window.renderFloorElements();
        document.getElementById("addElementModal").classList.remove("show");
        showToast("요소가 추가되었습니다.");
      });

      document.getElementById("cancelAddElementBtn").addEventListener("click", () => {
        document.getElementById("addElementModal").classList.remove("show");
      });

      // 요소 초기화 버튼
      document.getElementById("resetElementsBtn").addEventListener("click", () => {
        if (!state.currentFloorData) {
          showToast("먼저 층 데이터를 불러오세요.", "error");
          return;
        }

        if (!confirm("모든 요소와 현위치를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.")) {
          return;
        }

        // 모든 요소 삭제
        state.currentFloorData.elements = [];

        // 현위치 좌표 초기화
        state.currentFloorData.currentLocation = {
          enabled: false,
          x1: 50,
          y1: 50,
          x2: 100,
          y2: 100,
          showLabel: true,
          labelText: "현위치",
          labelStyle: {
            fontSize: 11,
            fontFamily: "Pretendard",
            fontWeight: "bold",
            color: THEME.textDark,
            backgroundColor: THEME.currentLocation,
            borderRadius: 12
          }
        };

        // 현위치 토글 버튼 상태 초기화
        document.getElementById("toggleCurrentLocationBtn").classList.remove("active");

        window.renderFloorElements();
        document.getElementById("addElementModal").classList.remove("show");
        showToast("모든 요소와 현위치가 초기화되었습니다.");
      });

      // 새 아이콘 타입 추가 버튼
      document.getElementById("addNewIconTypeBtn").addEventListener("click", () => {
        document.getElementById("addIconTypeModal").classList.add("show");
        document.getElementById("newIconTypeLabel").value = "";
        document.getElementById("newIconTypeFile").value = "";
        document.getElementById("selectedIconFileName").textContent = "파일을 선택하세요";
        document.getElementById("iconPreviewContainer").style.display = "none";
      });

      document.getElementById("selectIconFileBtn").addEventListener("click", () => {
        document.getElementById("newIconTypeFile").click();
      });

      document.getElementById("newIconTypeFile").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          document.getElementById("selectedIconFileName").textContent = file.name;
          // 미리보기
          const reader = new FileReader();
          reader.onload = (e) => {
            document.getElementById("iconPreview").src = e.target.result;
            document.getElementById("iconPreviewContainer").style.display = "block";
          };
          reader.readAsDataURL(file);
        }
      });

      document.getElementById("cancelAddIconTypeBtn").addEventListener("click", () => {
        document.getElementById("addIconTypeModal").classList.remove("show");
      });

      document.getElementById("confirmAddIconTypeBtn").addEventListener("click", async () => {
        const iconLabel = document.getElementById("newIconTypeLabel").value.trim();
        const iconFile = document.getElementById("newIconTypeFile").files[0];

        if (!iconLabel) {
          showToast("아이콘 라벨을 입력하세요.", "error");
          return;
        }

        if (!iconFile) {
          showToast("아이콘 이미지를 선택하세요.", "error");
          return;
        }

        try {
          // 아이콘 이미지 업로드 API 호출
          const formData = new FormData();
          formData.append("file", iconFile);
          formData.append("label", iconLabel);

          const uploadRes = await fetch(`${API_BASE}/icons/upload`, {
            method: "POST",
            body: formData
          });

          if (uploadRes.ok) {
            const uploadData = await uploadRes.json();
            const iconId = uploadData.data.id;
            const iconPath = uploadData.data.icon;

            // 아이콘 타입 추가
            if (!state.currentFloorData.iconTypes) {
              state.currentFloorData.iconTypes = {};
            }
            state.currentFloorData.iconTypes[iconId] = {
              icon: iconPath,
              label: iconLabel
            };

            showToast(`"${iconLabel}" 아이콘이 추가되었습니다.`);
            document.getElementById("addIconTypeModal").classList.remove("show");

            // 아이콘 타입 선택 목록 다시 렌더링
            loadIconTypes();
          } else {
            const errorData = await uploadRes.json();
            showToast(errorData.detail || "아이콘 업로드에 실패했습니다.", "error");
          }
        } catch (error) {
          console.error("아이콘 업로드 오류:", error);
          showToast("아이콘 업로드에 실패했습니다.", "error");
        }
      });

      document.getElementById("addIconTypeModal").addEventListener("click", (e) => {
        if (e.target.id === "addIconTypeModal") {
          document.getElementById("addIconTypeModal").classList.remove("show");
        }
      });

      // ===== 이미지 리사이즈 모달 이벤트 =====
      const canvasWrapper = document.getElementById('imageResizeCanvasWrapper');

      // 드래그 시작
      canvasWrapper.addEventListener('mousedown', (e) => {
        if (!imageResizeState.originalImage) return;
        imageResizeState.isDragging = true;
        imageResizeState.dragStartX = e.clientX - imageResizeState.offsetX;
        imageResizeState.dragStartY = e.clientY - imageResizeState.offsetY;
        canvasWrapper.style.cursor = 'grabbing';
      });

      // 드래그 중
      document.addEventListener('mousemove', (e) => {
        if (!imageResizeState.isDragging) return;
        imageResizeState.offsetX = e.clientX - imageResizeState.dragStartX;
        imageResizeState.offsetY = e.clientY - imageResizeState.dragStartY;
        updateImageResizePreview();
      });

      // 드래그 종료
      document.addEventListener('mouseup', () => {
        if (imageResizeState.isDragging) {
          imageResizeState.isDragging = false;
          canvasWrapper.style.cursor = 'grab';
        }
      });

      // 스케일 슬라이더
      document.getElementById('imageScaleSlider').addEventListener('input', (e) => {
        const newScale = parseInt(e.target.value);
        const oldScale = imageResizeState.scale;
        const img = imageResizeState.originalImage;

        if (!img) return;

        // 중심점 유지하면서 스케일 변경
        const centerX = 400;
        const centerY = 300;
        const oldWidth = img.width * (oldScale / 100);
        const oldHeight = img.height * (oldScale / 100);
        const newWidth = img.width * (newScale / 100);
        const newHeight = img.height * (newScale / 100);

        imageResizeState.offsetX += (oldWidth - newWidth) / 2;
        imageResizeState.offsetY += (oldHeight - newHeight) / 2;
        imageResizeState.scale = newScale;

        updateImageResizePreview();
        updateScaleInfo();
      });

      // 확대 버튼
      document.getElementById('zoomInBtn').addEventListener('click', () => {
        const slider = document.getElementById('imageScaleSlider');
        const newValue = Math.min(300, parseInt(slider.value) + 10);
        slider.value = newValue;
        slider.dispatchEvent(new Event('input'));
      });

      // 축소 버튼
      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        const slider = document.getElementById('imageScaleSlider');
        const newValue = Math.max(10, parseInt(slider.value) - 10);
        slider.value = newValue;
        slider.dispatchEvent(new Event('input'));
      });

      // 캔버스에 맞추기 버튼
      document.getElementById('fitToCanvasBtn').addEventListener('click', fitImageToCanvas);

      // 취소 버튼
      document.getElementById('cancelImageResizeBtn').addEventListener('click', () => {
        document.getElementById('imageResizeModal').classList.remove('show');
        if (imageResizeState.rejectCallback) {
          imageResizeState.rejectCallback(new Error('사용자가 취소했습니다.'));
        }
        // 상태 초기화
        imageResizeState.originalFile = null;
        imageResizeState.originalImage = null;
        imageResizeState.resolveCallback = null;
        imageResizeState.rejectCallback = null;
      });

      // 적용하기 버튼
      document.getElementById('confirmImageResizeBtn').addEventListener('click', async () => {
        try {
          const resizedFile = await generateResizedImage();
          document.getElementById('imageResizeModal').classList.remove('show');
          if (imageResizeState.resolveCallback) {
            imageResizeState.resolveCallback(resizedFile);
          }
        } catch (error) {
          showToast('이미지 생성에 실패했습니다.', 'error');
          if (imageResizeState.rejectCallback) {
            imageResizeState.rejectCallback(error);
          }
        }
        // 상태 초기화
        imageResizeState.originalFile = null;
        imageResizeState.originalImage = null;
        imageResizeState.resolveCallback = null;
        imageResizeState.rejectCallback = null;
      });

      // 모달 외부 클릭으로 닫기
      document.getElementById('imageResizeModal').addEventListener('click', (e) => {
        if (e.target.id === 'imageResizeModal') {
          document.getElementById('cancelImageResizeBtn').click();
        }
      });

      // ===== 콘텐츠 이미지 리사이즈 모달 이벤트 (메인/홍보 화면용) =====
      const contentCanvasWrapper = document.getElementById('contentResizeCanvasWrapper');
      const contentCropBox = document.getElementById('contentCropBox');
      const aspectRatio = () => contentResizeState.outputWidth / contentResizeState.outputHeight;

      // 크롭 박스 드래그 시작
      contentCropBox.addEventListener('mousedown', (e) => {
        if (!contentResizeState.originalImage) return;
        if (e.target.classList.contains('crop-box-handle')) return; // 핸들 클릭은 제외

        contentResizeState.isDragging = true;
        const rect = contentCanvasWrapper.getBoundingClientRect();
        contentResizeState.dragStartX = e.clientX - rect.left - contentResizeState.cropBox.x;
        contentResizeState.dragStartY = e.clientY - rect.top - contentResizeState.cropBox.y;
        e.preventDefault();
      });

      // 핸들 리사이즈 시작
      contentCropBox.querySelectorAll('.crop-box-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          if (!contentResizeState.originalImage) return;
          contentResizeState.isResizing = true;
          contentResizeState.resizeHandle = handle.dataset.handle;
          const rect = contentCanvasWrapper.getBoundingClientRect();
          contentResizeState.dragStartX = e.clientX - rect.left;
          contentResizeState.dragStartY = e.clientY - rect.top;
          contentResizeState.dragStartCropBox = { ...contentResizeState.cropBox };
          e.preventDefault();
          e.stopPropagation();
        });
      });

      // 드래그/리사이즈 중
      document.addEventListener('mousemove', (e) => {
        if (!contentResizeState.originalImage) return;
        const rect = contentCanvasWrapper.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (contentResizeState.isDragging) {
          // 크롭 박스 드래그
          const newX = mouseX - contentResizeState.dragStartX;
          const newY = mouseY - contentResizeState.dragStartY;

          // 경계 체크
          contentResizeState.cropBox.x = Math.max(0, Math.min(newX, contentResizeState.canvasWidth - contentResizeState.cropBox.width));
          contentResizeState.cropBox.y = Math.max(0, Math.min(newY, contentResizeState.canvasHeight - contentResizeState.cropBox.height));

          updateContentResizePreview();
          updateContentCropInfo();
        } else if (contentResizeState.isResizing) {
          // 크롭 박스 리사이즈
          const handle = contentResizeState.resizeHandle;
          const startBox = contentResizeState.dragStartCropBox;
          const ratio = aspectRatio();
          const deltaX = mouseX - contentResizeState.dragStartX;
          const deltaY = mouseY - contentResizeState.dragStartY;
          let newBox = { ...startBox };

          // 모서리 핸들 처리
          if (handle === 'se') {
            // 남동쪽 모서리
            const newWidth = Math.max(50, Math.min(startBox.width + deltaX, contentResizeState.canvasWidth - startBox.x));
            const newHeight = Math.max(50, Math.min(startBox.height + deltaY, contentResizeState.canvasHeight - startBox.y));
            // 비율 유지하면서 더 작은 값 선택
            if (newWidth / newHeight > ratio) {
              newBox.width = newHeight * ratio;
              newBox.height = newHeight;
            } else {
              newBox.width = newWidth;
              newBox.height = newWidth / ratio;
            }
          } else if (handle === 'sw') {
            // 남서쪽 모서리
            const newWidth = Math.max(50, Math.min(startBox.width - deltaX, startBox.x + startBox.width));
            const newHeight = Math.max(50, Math.min(startBox.height + deltaY, contentResizeState.canvasHeight - startBox.y));
            if (newWidth / newHeight > ratio) {
              newBox.width = newHeight * ratio;
              newBox.height = newHeight;
            } else {
              newBox.width = newWidth;
              newBox.height = newWidth / ratio;
            }
            newBox.x = startBox.x + startBox.width - newBox.width;
          } else if (handle === 'ne') {
            // 북동쪽 모서리
            const newWidth = Math.max(50, Math.min(startBox.width + deltaX, contentResizeState.canvasWidth - startBox.x));
            const newHeight = Math.max(50, Math.min(startBox.height - deltaY, startBox.y + startBox.height));
            if (newWidth / newHeight > ratio) {
              newBox.width = newHeight * ratio;
              newBox.height = newHeight;
            } else {
              newBox.width = newWidth;
              newBox.height = newWidth / ratio;
            }
            newBox.y = startBox.y + startBox.height - newBox.height;
          } else if (handle === 'nw') {
            // 북서쪽 모서리
            const newWidth = Math.max(50, Math.min(startBox.width - deltaX, startBox.x + startBox.width));
            const newHeight = Math.max(50, Math.min(startBox.height - deltaY, startBox.y + startBox.height));
            if (newWidth / newHeight > ratio) {
              newBox.width = newHeight * ratio;
              newBox.height = newHeight;
            } else {
              newBox.width = newWidth;
              newBox.height = newWidth / ratio;
            }
            newBox.x = startBox.x + startBox.width - newBox.width;
            newBox.y = startBox.y + startBox.height - newBox.height;
          } else if (handle === 'e') {
            // 동쪽
            const newWidth = Math.max(50, Math.min(startBox.width + deltaX, contentResizeState.canvasWidth - startBox.x));
            newBox.width = newWidth;
            newBox.height = newWidth / ratio;
          } else if (handle === 'w') {
            // 서쪽
            const newWidth = Math.max(50, Math.min(startBox.width - deltaX, startBox.x + startBox.width));
            newBox.width = newWidth;
            newBox.height = newWidth / ratio;
            newBox.x = startBox.x + startBox.width - newBox.width;
          } else if (handle === 's') {
            // 남쪽
            const newHeight = Math.max(50, Math.min(startBox.height + deltaY, contentResizeState.canvasHeight - startBox.y));
            newBox.height = newHeight;
            newBox.width = newHeight * ratio;
          } else if (handle === 'n') {
            // 북쪽
            const newHeight = Math.max(50, Math.min(startBox.height - deltaY, startBox.y + startBox.height));
            newBox.height = newHeight;
            newBox.width = newHeight * ratio;
            newBox.y = startBox.y + startBox.height - newBox.height;
          }

          // 경계 체크 및 조정
          if (newBox.x < 0) {
            newBox.width += newBox.x;
            newBox.x = 0;
            newBox.height = newBox.width / ratio;
          }
          if (newBox.y < 0) {
            newBox.height += newBox.y;
            newBox.y = 0;
            newBox.width = newBox.height * ratio;
          }
          if (newBox.x + newBox.width > contentResizeState.canvasWidth) {
            newBox.width = contentResizeState.canvasWidth - newBox.x;
            newBox.height = newBox.width / ratio;
          }
          if (newBox.y + newBox.height > contentResizeState.canvasHeight) {
            newBox.height = contentResizeState.canvasHeight - newBox.y;
            newBox.width = newBox.height * ratio;
          }

          contentResizeState.cropBox = newBox;
          updateContentResizePreview();
          updateContentCropInfo();
        }
      });

      // 드래그/리사이즈 종료
      document.addEventListener('mouseup', () => {
        if (contentResizeState.isDragging || contentResizeState.isResizing) {
          contentResizeState.isDragging = false;
          contentResizeState.isResizing = false;
          contentResizeState.resizeHandle = null;
          contentResizeState.dragStartCropBox = null;
        }
      });

      // 취소 버튼
      document.getElementById('cancelContentResizeBtn').addEventListener('click', () => {
        document.getElementById('contentResizeModal').classList.remove('show');
        if (contentResizeState.rejectCallback) {
          contentResizeState.rejectCallback(new Error('사용자가 취소했습니다.'));
        }
        // 상태 초기화
        contentResizeState.originalFile = null;
        contentResizeState.originalImage = null;
        contentResizeState.resolveCallback = null;
        contentResizeState.rejectCallback = null;
      });

      // 적용 및 업로드 버튼
      document.getElementById('confirmContentResizeBtn').addEventListener('click', async () => {
        try {
          showToast('이미지 처리 중...', 'info');

          // 메인 이미지와 썸네일 생성
          const images = await generateAllContentImages();

          // 콘텐츠 타입에 따라 업로드
          if (contentResizeState.contentType === 'dashboard') {
            await uploadDashboardImage(images.main);
          } else {
            await uploadPrImage(images.main);
          }

          document.getElementById('contentResizeModal').classList.remove('show');
          if (contentResizeState.resolveCallback) {
            contentResizeState.resolveCallback(images);
          }
        } catch (error) {
          showToast('이미지 처리에 실패했습니다.', 'error');
          if (contentResizeState.rejectCallback) {
            contentResizeState.rejectCallback(error);
          }
        }
        // 상태 초기화
        contentResizeState.originalFile = null;
        contentResizeState.originalImage = null;
        contentResizeState.resolveCallback = null;
        contentResizeState.rejectCallback = null;
      });

      // 모달 외부 클릭으로 닫기
      document.getElementById('contentResizeModal').addEventListener('click', (e) => {
        if (e.target.id === 'contentResizeModal') {
          document.getElementById('cancelContentResizeBtn').click();
        }
      });

      document.getElementById("toggleCurrentLocationBtn").addEventListener("click", () => {
        const toggleBtn = document.getElementById("toggleCurrentLocationBtn");

        if (!state.currentFloorData) {
          showToast("먼저 층 데이터를 불러오세요.", "error");
          return;
        }

        if (!state.currentFloorData.currentLocation) {
          state.currentFloorData.currentLocation = {
            enabled: true,
            x1: 50,
            y1: 50,
            x2: 100,
            y2: 100,
            showLabel: true,
            labelText: "현위치",
            labelStyle: {
              fontSize: 11,
              fontFamily: "Pretendard",
              fontWeight: "bold",
              color: THEME.textDark,
              backgroundColor: THEME.currentLocation,
              borderRadius: 12
            }
          };
        } else {
          state.currentFloorData.currentLocation.enabled = !state.currentFloorData.currentLocation.enabled;
        }

        // 토글 버튼 상태 업데이트
        if (state.currentFloorData.currentLocation.enabled) {
          toggleBtn.classList.add("active");
        } else {
          toggleBtn.classList.remove("active");
        }

        renderCurrentLocation();
        showToast(
          state.currentFloorData.currentLocation.enabled
            ? "현위치가 표시되었습니다."
            : "현위치가 숨겨졌습니다."
        );
      });

      document.getElementById("saveFloorBtn").addEventListener("click", async () => {
        if (!state.currentBuilding || !state.currentFloor || !state.currentFloorData) {
          showToast("저장할 데이터가 없습니다.", "error");
          return;
        }

        // currentLocation 위치 업데이트
        updateCurrentLocationPosition();

        // buildingId 필드 보장
        if (!state.currentFloorData.buildingId) {
          state.currentFloorData.buildingId = state.currentBuilding;
        }
        // floor 필드 보장
        if (!state.currentFloorData.floor) {
          state.currentFloorData.floor = state.currentFloor;
        }
        // updatedAt 업데이트
        state.currentFloorData.updatedAt = new Date().toISOString();

        try {
          const res = await apiSaveBuildingFloor(state.currentBuilding, state.currentFloor, state.currentFloorData);
          if (res.code === 200) {
            showToast("청사도 데이터가 저장되었습니다.");
            // 층 목록 새로고침
            const floorsRes = await apiGetBuildingFloors(state.currentBuilding);
            if (floorsRes.code === 200) {
              state.floorPlans = floorsRes.data;
              renderFloorList();
            }
          } else {
            showToast(res.detail || "저장에 실패했습니다.", "error");
          }
        } catch (error) {
          showToast("저장에 실패했습니다.", "error");
        }
      });

      // 모달 외부 클릭으로 닫기
      document.getElementById("addElementModal").addEventListener("click", (e) => {
        if (e.target.id === "addElementModal") {
          document.getElementById("addElementModal").classList.remove("show");
        }
      });

      // 초기화 - Auth 및 Router 초기화
      Auth.init();
      Router.init();
    });
  </script>
</body>

</html>